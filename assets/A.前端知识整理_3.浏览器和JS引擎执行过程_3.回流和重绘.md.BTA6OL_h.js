import{_ as s,c as n,o as a,a8 as l,a$ as e,b0 as p,b1 as o}from"./chunks/framework.6k5lawSO.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"A.前端知识整理/3.浏览器和JS引擎执行过程/3.回流和重绘.md","filePath":"A.前端知识整理/3.浏览器和JS引擎执行过程/3.回流和重绘.md","lastUpdated":1687956671000}'),t={name:"A.前端知识整理/3.浏览器和JS引擎执行过程/3.回流和重绘.md"},r=l('<p>回流（reflow）和重绘（repaint）是浏览器渲染过程中的两个重要概念。</p><p><strong>回流，也称为重排，是指浏览器重新计算元素的大小和位置</strong>。当页面布局发生变化时，浏览器需要重新计算元素的布局。回流的触发条件包括：DOM结构发生改变（如添加或移除节点）、修改元素的布局属性（如宽度、高度、内边距等）、窗口尺寸发生变化（如窗口缩放）等。</p><p><img src="'+e+'" alt="图 1"></p><p>从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的</p><p><strong>重绘，是指浏览器重新渲染页面的内容</strong>。当元素的视觉样式发生变化时，浏览器需要重新绘制这些元素。重绘的触发条件包括：修改元素的背景色、文字颜色、边框颜色等样式属性。</p><p><img src="'+p+'" alt="图 2"></p><p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p><p>需要注意的是，<strong>回流一定会引起重绘</strong>，因为元素的大小和位置发生变化后，浏览器需要重新绘制这些元素。但是，<strong>重绘不一定会引起回流</strong>。由于回流涉及到重新计算布局，因此它是一个性能消耗较大的过程。在进行页面优化时，应尽量减少回流和重绘的次数，以提高页面性能。</p><p><strong>合成</strong>，更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成</p><p><img src="'+o+`" alt="图 3"></p><p>在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，<strong>所以相对于重绘和重排，合成能大大提升绘制效率</strong></p><h2 id="避免回流" tabindex="-1">避免回流 <a class="header-anchor" href="#避免回流" aria-label="Permalink to &quot;避免回流&quot;">​</a></h2><ol><li>一次性修改样式：在修改元素样式时，尽量一次性完成，可以通过设置cssText属性或者添加class的方式来实现。这样可以避免多次修改样式导致的性能损耗。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-light vp-code" tabindex="0"><code><span class="line"><span style="color:#A0A1A7;font-style:italic;">// 改变dom高度和设置margin分开写，可能会出发两次重排 这样就一次了</span></span>
<span class="line"><span style="color:#383A42;">box.</span><span style="color:#E45649;">style</span><span style="color:#383A42;">.</span><span style="color:#E45649;">cssText</span><span style="color:#0184BC;"> =</span><span style="color:#50A14F;"> &quot;width: 200px; height: 200px; background-color: blue;&quot;</span><span style="color:#383A42;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="2"><li>避免频繁操作DOM：在对DOM元素进行操作时，尽量减少直接对页面上的元素进行操作。可以使用DocumentFragment或者父元素来完成需要的DOM操作，然后再一次性地将修改应用到页面上。这样可以减少页面的重绘和回流，提高性能。下面代码循环不停操作样式改变</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-light vp-code" tabindex="0"><code><span class="line"><span style="color:#A626A4;">function</span><span style="color:#4078F2;"> foo</span><span style="color:#383A42;">() {</span></span>
<span class="line"><span style="color:#A626A4;">    let</span><span style="color:#383A42;"> time_li </span><span style="color:#0184BC;">=</span><span style="color:#383A42;"> document.</span><span style="color:#4078F2;">getElementById</span><span style="color:#383A42;">(</span><span style="color:#50A14F;">&quot;time_li&quot;</span><span style="color:#383A42;">)</span></span>
<span class="line"><span style="color:#A626A4;">    for</span><span style="color:#383A42;"> (</span><span style="color:#A626A4;">let</span><span style="color:#383A42;"> i </span><span style="color:#0184BC;">=</span><span style="color:#986801;"> 0</span><span style="color:#383A42;">; i </span><span style="color:#0184BC;">&lt;</span><span style="color:#986801;"> 100</span><span style="color:#383A42;">; i</span><span style="color:#0184BC;">++</span><span style="color:#383A42;">) {</span></span>
<span class="line"><span style="color:#A626A4;">        let</span><span style="color:#383A42;"> main_div </span><span style="color:#0184BC;">=</span><span style="color:#383A42;"> document.</span><span style="color:#4078F2;">getElementById</span><span style="color:#383A42;">(</span><span style="color:#50A14F;">&quot;mian_div&quot;</span><span style="color:#383A42;">)</span></span>
<span class="line"><span style="color:#A626A4;">        let</span><span style="color:#383A42;"> new_node </span><span style="color:#0184BC;">=</span><span style="color:#383A42;"> document.</span><span style="color:#4078F2;">createElement</span><span style="color:#383A42;">(</span><span style="color:#50A14F;">&quot;li&quot;</span><span style="color:#383A42;">)</span></span>
<span class="line"><span style="color:#A626A4;">        let</span><span style="color:#383A42;"> textnode </span><span style="color:#0184BC;">=</span><span style="color:#383A42;"> document.</span><span style="color:#4078F2;">createTextNode</span><span style="color:#383A42;">(</span><span style="color:#50A14F;">&quot;time.geekbang&quot;</span><span style="color:#383A42;">)</span></span>
<span class="line"><span style="color:#383A42;">        new_node.</span><span style="color:#4078F2;">appendChild</span><span style="color:#383A42;">(textnode);</span></span>
<span class="line"><span style="color:#383A42;">        new_node.</span><span style="color:#E45649;">offsetHeight</span><span style="color:#0184BC;"> =</span><span style="color:#383A42;"> time_li.</span><span style="color:#E45649;">offsetHeight</span><span style="color:#383A42;">;</span></span>
<span class="line"><span style="color:#383A42;">        document.</span><span style="color:#4078F2;">getElementById</span><span style="color:#383A42;">(</span><span style="color:#50A14F;">&quot;mian_div&quot;</span><span style="color:#383A42;">).</span><span style="color:#4078F2;">appendChild</span><span style="color:#383A42;">(new_node);</span></span>
<span class="line"><span style="color:#383A42;">    }</span></span>
<span class="line"><span style="color:#383A42;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="3"><li>使用position的absolute或者fixed：对于某些元素，可以使用position属性的absolute或者fixed值来进行定位。这样的元素在进行回流时，开销相对较小，不会对其他元素造成影响。这也有助于提高页面的性能。</li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://time.geekbang.org/column/intro/100033601?utm_source=pinpaizhuanqu&amp;utm_medium=geektime&amp;utm_campaign=guanwang&amp;utm_term=guanwang&amp;utm_content=0511" target="_blank" rel="noreferrer">浏览器工作原理与实践_李兵</a></p>`,19),c=[r];function i(y,d,m,u,A,_){return a(),n("div",null,c)}const h=s(t,[["render",i]]);export{g as __pageData,h as default};
