import{_ as t,o as d,c as r,O as e}from"./chunks/framework.ab95ac3d.js";const q=JSON.parse('{"title":"","description":"了解Express.js 种回调参数","frontmatter":{"description":"了解Express.js 种回调参数","tags":["服务端","express"]},"headers":[],"relativePath":"B.NodeJS学习/12.express服务端框架/3.express回调函数中参数.md","filePath":"B.NodeJS学习/12.express服务端框架/3.express回调函数中参数.md","lastUpdated":1684680743000}'),s={name:"B.NodeJS学习/12.express服务端框架/3.express回调函数中参数.md"},o=e('<p><strong>callback</strong> 回调函数函数里面的参数有 ,请求对象（request对象）、响应对象（response对象）、next函数（在express中定义的用于执行下一个中间件的函数）</p><table><thead><tr><th>属性/方法</th><th>参数</th><th>解释</th></tr></thead><tbody><tr><td><strong>req.body</strong></td><td></td><td>包含 POST 请求体中提交的数据的对象。在使用中间件解析请求体后可用。</td></tr><tr><td><strong>req.cookies</strong></td><td></td><td>包含解析的 cookies 的对象。会自动解析 HTTP 请求中的 cookie 字段。</td></tr><tr><td><strong>req.get(header)</strong></td><td>header</td><td>获取指定请求头的值。如果请求头存在多个值，则返回第一个值。</td></tr><tr><td><strong>req.header(header)</strong></td><td>header</td><td>获取指定请求头的值。如果请求头存在多个值，则返回以逗号分隔的字符串。</td></tr><tr><td><strong>req.hostname</strong></td><td></td><td>返回主机名，如 &quot;example.com&quot;。</td></tr><tr><td><strong>req.ip</strong></td><td></td><td>返回客户端的 IP 地址。</td></tr><tr><td><strong>req.path</strong></td><td></td><td>返回 URL 的路径部分，如 &quot;/user&quot;。</td></tr><tr><td><strong>req.params</strong></td><td></td><td>包含以冒号标记的路由参数的对象。例如，在路由路径 /user/:id 中，如果一个请求的 URL 为/user/123，则 req.params 拥有一个属性 id，其值为 &quot;123&quot;。</td></tr><tr><td><strong>req.protocol</strong></td><td></td><td>返回请求协议，如 &quot;http&quot; 或 &quot;https&quot;。</td></tr><tr><td><strong>req.query</strong></td><td></td><td>包含 URL 查询参数的对象。例如，在 URL &quot;/user?id=123&quot; 中， req.query 拥有一个属性 id，其值为 &quot;123&quot;。</td></tr><tr><td><strong>req.secure</strong></td><td></td><td>如果请求通过 HTTPS 协议，则返回 true。</td></tr><tr><td><strong>req.url</strong></td><td></td><td>返回完整的 URL，包括查询参数和哈希部分。</td></tr><tr><td><strong>req.xhr</strong></td><td></td><td>如果请求通过 AJAX 发起，则返回 true。</td></tr></tbody></table><table><thead><tr><th>属性/方法</th><th>参数</th><th>解释</th></tr></thead><tbody><tr><td><strong>res.append(field, value)</strong></td><td>field, value</td><td>在响应头中添加一个值。</td></tr><tr><td><strong>res.cookie(name, value, options)</strong></td><td>name, value, options</td><td>设置一个 HTTP cookie。</td></tr><tr><td><strong>res.clearCookie(name, options)</strong></td><td>name, options</td><td>删除一个 HTTP cookie。</td></tr><tr><td><strong>res.download(path, [filename], [options], [callback])</strong></td><td>path, filename, options, callback</td><td>提供文件下载。</td></tr><tr><td><strong>res.end([data], [encoding])</strong></td><td>data, encoding</td><td>结束响应流，并发送响应数据。如果提供了数据，则相当于同时调用 res.write() 和 res.end()。</td></tr><tr><td><strong>res.format(obj)</strong></td><td>obj</td><td>根据请求 Accept 头发送不同的响应格式。</td></tr><tr><td><strong>res.get(field)</strong></td><td>field</td><td>获取响应头中指定字段的值。如果响应头存在多个值，则返回第一个值。</td></tr><tr><td><strong>res.json([body])</strong></td><td>body</td><td>发送一个 JSON 格式的响应。</td></tr><tr><td><strong>res.jsonp([body])</strong></td><td>body</td><td>发送一个 JSONP 格式的响应。</td></tr><tr><td><strong>res.links(links)</strong></td><td>links</td><td>发送 Link 标头。</td></tr><tr><td><strong>res.location(url)</strong></td><td>url</td><td>设置 &quot;Location&quot; 响应头，将客户端重定向到指定的 URL。</td></tr><tr><td><strong>res.redirect([status,] path)</strong></td><td>status, path</td><td>将客户端重定向到指定的 URL。</td></tr><tr><td><strong>res.render(view [, locals] [, callback])</strong></td><td>view, locals, callback</td><td>通过模板引擎渲染模板，并发送响应。</td></tr><tr><td><strong>res.send([body])</strong></td><td>body</td><td>发送一个 HTTP 响应。针对不同类型的数据采用适当的响应头。</td></tr><tr><td><strong>res.sendFile(path [, options] [, fn])</strong></td><td>path, options, fn</td><td>发送文件。</td></tr><tr><td><strong>res.setHeader(name, value)</strong></td><td>name, value</td><td>设置响应头的值。</td></tr><tr><td><strong>res.status(code)</strong></td><td>code</td><td>设定 HTTP 响应状态码。</td></tr><tr><td><strong>res.type(type)</strong></td><td>type</td><td>设置 Content-Type 响应头的值。</td></tr><tr><td>res.sendStatus()</td><td>statusCode</td><td>用于发送HTTP状态码作为响应。它会自动设置响应头的Content-Type为text/plain，并将状态码作为响应主体发送给客户端。例如，res.sendStatus(404)将发送一个状态码为404的响应给客户端。</td></tr></tbody></table><p>next() 是用于传递请求到下一个 middleware 或者路由处理函数中的一个函数，如果没有执行 next()，那么请求将被阻塞，无法响应客户端。如果传入了参数，则 Express 会认为这是一个错误，并交给内置的错误处理函数处理。如果在中间件函数中调用了 next(&quot;some error message&quot;)，那么这个请求会被 Express 视为发生了错误，并交给 Express 内置的 error handler 函数处理。</p><h2 id="额外补充" tabindex="-1">额外补充 <a class="header-anchor" href="#额外补充" aria-label="Permalink to &quot;额外补充&quot;">​</a></h2><p>客户端传递到服务器参数的方法常见的是5种：</p><p>方式一：通过get请求中的URL的params；</p><p>方式二：通过get请求中的URL的query；</p><p>方式三：通过post请求中的body的json格式；</p><p>方式四：通过post请求中的body的x-www-form-urlencoded格式；</p><p>方式五：通过post请求中的form-data格式；</p>',11),n=[o];function a(p,g,i,l,c,u){return d(),r("div",null,n)}const _=t(s,[["render",a]]);export{q as __pageData,_ as default};
