import{_ as s,c as n,o as a,a8 as l}from"./chunks/framework.6k5lawSO.js";const A=JSON.parse('{"title":"","description":"高层模块不应该依赖低层模块，二者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。","frontmatter":{"description":"高层模块不应该依赖低层模块，二者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。"},"headers":[],"relativePath":"G.设计模式/2.设计原则/5.SOLID原则/5.依赖倒置原则（DIP）.md","filePath":"G.设计模式/2.设计原则/5.SOLID原则/5.依赖倒置原则（DIP）.md","lastUpdated":1690115031000}'),e={name:"G.设计模式/2.设计原则/5.SOLID原则/5.依赖倒置原则（DIP）.md"},p=l(`<p>依赖反转原则（DIP）是一种面向对象设计原则。依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><p>在通俗说法高层模块不应该依赖低层模块，二者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。这个原则的目的是减少模块之间的耦合，提高代码的可维护性和可扩展性。在实践中，可以通过使用接口或抽象类来实现依赖倒置原则，依赖倒置原则的核心思想是0面向接口编程比相对于面向实现编程好</p><h2 id="代码" tabindex="-1">代码 <a class="header-anchor" href="#代码" aria-label="Permalink to &quot;代码&quot;">​</a></h2><p>假设我们有一个Person类，这个类有一个read方法，用来读取一本书的内容。如果不使用依赖倒置原则，我们可能会这样写代码</p><div class="language-java line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki one-light vp-code" tabindex="0"><code><span class="line"><span style="color:#A626A4;">class</span><span style="color:#C18401;"> Book </span><span style="color:#383A42;">{</span></span>
<span class="line"><span style="color:#A626A4;">    public</span><span style="color:#C18401;"> String</span><span style="color:#4078F2;"> getContent</span><span style="color:#383A42;">() {</span></span>
<span class="line"><span style="color:#A626A4;">        return</span><span style="color:#50A14F;"> &quot;很好的一本书&quot;</span><span style="color:#383A42;">;</span></span>
<span class="line"><span style="color:#383A42;">    }</span></span>
<span class="line"><span style="color:#383A42;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A626A4;">class</span><span style="color:#C18401;"> Person </span><span style="color:#383A42;">{</span></span>
<span class="line"><span style="color:#A626A4;">    public</span><span style="color:#A626A4;"> void</span><span style="color:#4078F2;"> read</span><span style="color:#383A42;">(</span><span style="color:#C18401;">Book</span><span style="color:#383A42;"> book) {</span></span>
<span class="line"><span style="color:#E45649;">        System</span><span style="color:#383A42;">.</span><span style="color:#E45649;">out</span><span style="color:#383A42;">.</span><span style="color:#4078F2;">println</span><span style="color:#383A42;">(</span><span style="color:#E45649;">book</span><span style="color:#383A42;">.</span><span style="color:#4078F2;">getContent</span><span style="color:#383A42;">());</span></span>
<span class="line"><span style="color:#383A42;">    }</span></span>
<span class="line"><span style="color:#383A42;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这段代码的问题在于，Person类直接依赖了Book类。如果未来我们想让Person类读取其他类型的内容，比如一个电子书或者一个网页，我们就需要修改Person类的代码。</p><p>但是，如果我们使用依赖倒置原则，我们可以先定义一个抽象的Readable接口，然后让Book类实现这个接口：</p><div class="language-java line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki one-light vp-code" tabindex="0"><code><span class="line"><span style="color:#A626A4;">interface</span><span style="color:#C18401;"> Readable </span><span style="color:#383A42;">{</span></span>
<span class="line"><span style="color:#C18401;">    String</span><span style="color:#4078F2;"> getContent</span><span style="color:#383A42;">();</span></span>
<span class="line"><span style="color:#383A42;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A626A4;">class</span><span style="color:#C18401;"> Book </span><span style="color:#A626A4;">implements</span><span style="color:#C18401;"> Readable </span><span style="color:#383A42;">{</span></span>
<span class="line"><span style="color:#A626A4;">    public</span><span style="color:#C18401;"> String</span><span style="color:#4078F2;"> getContent</span><span style="color:#383A42;">() {</span></span>
<span class="line"><span style="color:#A626A4;">        return</span><span style="color:#50A14F;"> &quot;很好的一本书&quot;</span><span style="color:#383A42;">;</span></span>
<span class="line"><span style="color:#383A42;">    }</span></span>
<span class="line"><span style="color:#383A42;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A626A4;">class</span><span style="color:#C18401;"> Person </span><span style="color:#383A42;">{</span></span>
<span class="line"><span style="color:#A626A4;">    public</span><span style="color:#A626A4;"> void</span><span style="color:#4078F2;"> read</span><span style="color:#383A42;">(</span><span style="color:#C18401;">Readable</span><span style="color:#383A42;"> readable) {</span></span>
<span class="line"><span style="color:#E45649;">        System</span><span style="color:#383A42;">.</span><span style="color:#E45649;">out</span><span style="color:#383A42;">.</span><span style="color:#4078F2;">println</span><span style="color:#383A42;">(</span><span style="color:#E45649;">readable</span><span style="color:#383A42;">.</span><span style="color:#4078F2;">getContent</span><span style="color:#383A42;">());</span></span>
<span class="line"><span style="color:#383A42;">    }</span></span>
<span class="line"><span style="color:#383A42;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这样，无论未来我们的内容是一本书，一个电子书，还是一个网页，只要它们实现了Readable接口，Person类就可以读取它们的内容，而不需要做任何修改。这就是依赖倒置原则的作用。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>依赖倒置原则其实就是说，我们在编程的时候，应该让上层代码依赖下层代码的抽象概念，而不是依赖下层代码的具体实现。</p><p>举个例子，假设你在设计一个电脑系统，这个系统有一个“播放音乐”的功能。在没有使用依赖倒置原则的情况下，你可能会直接编写一段代码，让电脑通过某种特定的音箱来播放音乐。这就是上层代码（电脑系统）直接依赖了下层代码（特定音箱）的具体实现。</p><p>但是，如果我们按照依赖倒置原则来做，我们会先定义一个抽象的“音箱”接口，然后让电脑系统通过这个接口来播放音乐，具体使用哪种音箱，就由用户来决定。这样，无论未来音箱的技术怎么发展，只要它们都符合我们定义的“音箱”接口，我们的电脑系统都可以使用，不需要做任何修改。</p><p>所以，依赖倒置原则的核心思想就是：面向接口编程，而不是面向实现编程。这样可以让我们的代码更加灵活，更容易适应未来的变化。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=710#/detail/pc?id=6878" target="_blank" rel="noreferrer">反转原则：如何减少代码间的相互影响？</a></p><p><a href="https://geek-docs.com/design-pattern/design-principle/dependence-inversion-principle.html#ftoc-heading-3" target="_blank" rel="noreferrer">依赖倒置原则DIP</a></p><p><a href="https://time.geekbang.org/column/article/177444" target="_blank" rel="noreferrer">理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？</a></p>`,18),o=[p];function r(t,c,i,b,y,d){return a(),n("div",null,o)}const m=s(e,[["render",r]]);export{A as __pageData,m as default};
