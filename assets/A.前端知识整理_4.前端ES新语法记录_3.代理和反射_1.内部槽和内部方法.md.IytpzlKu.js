import{_ as e,c as t,o as r,a8 as o}from"./chunks/framework.6k5lawSO.js";const y=JSON.parse('{"title":"","description":"JavaScript 反射和代理（Reflect/Proxy）","frontmatter":{"description":"JavaScript 反射和代理（Reflect/Proxy）"},"headers":[],"relativePath":"A.前端知识整理/4.前端ES新语法记录/3.代理和反射/1.内部槽和内部方法.md","filePath":"A.前端知识整理/4.前端ES新语法记录/3.代理和反射/1.内部槽和内部方法.md","lastUpdated":1718893054000}'),a={name:"A.前端知识整理/4.前端ES新语法记录/3.代理和反射/1.内部槽和内部方法.md"},d=o('<p>在了解 <code>Reflect</code> 和 <code>Proxy</code> 之前，需要知道 JavaScript 规范以及引擎带有一系列的内部方法，例如 <code>[[Get]]</code>、<code>[[Set]]</code>、<code>[[Prototype]]</code> 等。这类用双 <code>[]</code> 包裹的属性被称为“内部槽和内部方法”（Internal slots and methods）。它们不是对象的属性，不能作为 JavaScript 代码的属性直接访问。</p><h3 id="什么是内部槽和内部方法" tabindex="-1">什么是内部槽和内部方法？ <a class="header-anchor" href="#什么是内部槽和内部方法" aria-label="Permalink to &quot;什么是内部槽和内部方法？&quot;">​</a></h3><p><strong>内部槽</strong>是 JavaScript 对象的数据成员或规范类型，用于存储对象的状态。例如，每个 JavaScript 对象都有一个 <code>[[Prototype]]</code> 内部槽，用于指向对象的原型。</p><p><strong>内部方法</strong>是 JavaScript 对象的成员函数。例如，每个 JavaScript 对象都有一个 <code>[[GetOwnProperty]]</code> 内部方法，由引擎在需要获取对象自身属性时调用。</p><p>这些内部槽和内部方法是 JavaScript 引擎内部实现的一部分，并不直接暴露给开发者。相反，它们通过规范来定义其行为和要求，从而保证不同引擎实现的一致性。</p><h3 id="为什么内部槽和内部方法很重要" tabindex="-1">为什么内部槽和内部方法很重要？ <a class="header-anchor" href="#为什么内部槽和内部方法很重要" aria-label="Permalink to &quot;为什么内部槽和内部方法很重要？&quot;">​</a></h3><p>内部槽和内部方法有助于确保 JavaScript 对象的一致行为。在不同的 JavaScript 引擎（如 V8、SpiderMonkey 等）中，尽管每个引擎可能有不同的实现方式，它们都必须按照同一套规范来实现这些内部槽和内部方法。</p><p>这使得 JavaScript 程序能够在不同的环境中表现出一致的行为，从而提高了代码的跨平台兼容性和可移植性。</p><h3 id="常见的内部方法" tabindex="-1">常见的内部方法 <a class="header-anchor" href="#常见的内部方法" aria-label="Permalink to &quot;常见的内部方法&quot;">​</a></h3><table tabindex="0"><thead><tr><th>内部方法</th><th>签名</th><th>描述</th></tr></thead><tbody><tr><td>[[GetPrototypeOf]]</td><td>() → Object / Null</td><td>获取对象的原型。返回提供继承属性的对象，若无，则返回<code>null</code>。对应方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noreferrer">Object.getPrototypeOf()</a></td></tr><tr><td>[[SetPrototypeOf]]</td><td>(Object / Null) → Boolean</td><td>设置对象的原型。将对象与另一个提供继承属性的对象关联。成功返回<code>true</code>，失败返回<code>false</code>。对应方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noreferrer">Object.setPrototypeOf()</a></td></tr><tr><td>[[IsExtensible]]</td><td>() → Boolean</td><td>判断对象是否可扩展。对应方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible" target="_blank" rel="noreferrer">Object.isExtensible()</a></td></tr><tr><td>[[PreventExtensions]]</td><td>() → Boolean</td><td>防止对象扩展。控制新属性是否能被加入对象内。成功返回<code>true</code>，失败返回<code>false</code>。对应方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="noreferrer">Object.preventExtensions()</a></td></tr><tr><td>[[GetOwnProperty]]</td><td>(propertyKey) → Undefined / <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#descriptor" target="_blank" rel="noreferrer">Property Descriptor</a></td><td>获取对象自身属性的属性描述符。若无对应属性，返回<code>undefined</code>。对应方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noreferrer">Object.getOwnPropertyDescriptor()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" target="_blank" rel="noreferrer">Object.getOwnPropertyDescriptors()</a></td></tr><tr><td>[[DefineOwnProperty]]</td><td>(propertyKey, PropertyDescriptor) → Boolean</td><td>定义或修改对象自己的属性。成功返回<code>true</code>，失败返回<code>false</code>。对应方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noreferrer">Object.defineProperty()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noreferrer">Object.defineProperties()</a></td></tr><tr><td>[[HasProperty]]</td><td>(propertyKey) → Boolean</td><td>判断对象是否拥有自身或继承的某个属性。对应方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="noreferrer">Object.prototype.hasOwnProperty()</a></td></tr><tr><td>[[Get]]</td><td>(propertyKey, Receiver) → any</td><td>获取对象中指定属性的值。如果需要执行ECMAScript代码来获得属性值，<code>Receiver</code> 被当作 <code>this</code> 使用。</td></tr><tr><td>[[Set]]</td><td>(propertyKey, value, Receiver) → Boolean</td><td>设置对象中指定属性的值。<code>Receiver</code> 被当作 <code>this</code> 使用。成功返回<code>true</code>，失败返回<code>false</code>。</td></tr><tr><td>[[Delete]]</td><td>(propertyKey) → Boolean</td><td>删除对象中指定属性。成功返回<code>true</code>，失败返回<code>false</code>。类似于 JavaScript 中的 <code>delete</code> 关键字。</td></tr><tr><td>[[OwnPropertyKeys]]</td><td>() → <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noreferrer">List</a> of propertyKey</td><td>返回包含对象自身所有属性键的列表。对应方法：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames" target="_blank" rel="noreferrer">Object.getOwnPropertyNames()</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="noreferrer">Object.getOwnPropertySymbols()</a></td></tr></tbody></table><h3 id="函数对象支持的其他基本内部方法" tabindex="-1">函数对象支持的其他基本内部方法 <a class="header-anchor" href="#函数对象支持的其他基本内部方法" aria-label="Permalink to &quot;函数对象支持的其他基本内部方法&quot;">​</a></h3><table tabindex="0"><thead><tr><th>内部方法</th><th>签名</th><th>描述</th></tr></thead><tbody><tr><td>[[Call]]</td><td>(any, a List of any) → any</td><td>执行与对象关联的代码。通过函数调用表达式调用。第一个参数表示 <code>this</code>，第二个参数是传入的参数列表。实现此内部方法的对象是可调用的。</td></tr><tr><td>[[Construct]]</td><td>(a List of any, Object) → Object</td><td>创建一个对象。通过 <code>new</code> 或 <code>super</code> 操作调用。第一个参数是包含运算符参数的列表，第二个参数是初始应用对象。实现该内部方法的对象称为 <code>constructors</code>。非构造函数对象没有 <code>[[Construct]]</code> 内部方法。</td></tr></tbody></table><h2 id="_2-proxy-和-reflect-的作用" tabindex="-1">2. Proxy 和 Reflect 的作用 <a class="header-anchor" href="#_2-proxy-和-reflect-的作用" aria-label="Permalink to &quot;2. Proxy 和 Reflect 的作用&quot;">​</a></h2><p>JavaScript 提供了 <code>Proxy</code> 和 <code>Reflect</code> 对象来拦截和操作这些内部方法的行为。</p>',14),c=[d];function l(p,n,s,i,b,h){return r(),t("div",null,c)}const _=e(a,[["render",l]]);export{y as __pageData,_ as default};
