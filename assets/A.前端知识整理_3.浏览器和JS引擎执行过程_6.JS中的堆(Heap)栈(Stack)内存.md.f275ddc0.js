import{_ as a,o as s,c as n,V as e}from"./chunks/framework.96db2af4.js";const l="/learning-notes-blog/images/29850e8ab257c82413ed5e4298cfdc73ec39f043795478e1da9d9e9298bac06a.png",p="/learning-notes-blog/images/3625eb3d2d85c2c73fa84a2a622297acbade4497b20c32cd95f6ee802a8f5e10.png",o="/learning-notes-blog/images/0a9ec42d3754fc339c500c4f29f0a408999481601ef0fef97e941edb4fb6122f.png",r="/learning-notes-blog/images/a4ce95288537ebcd654143d9ab77c1df2af91aab613af020cea428e265ce9081.png",t="/learning-notes-blog/images/23f970e9fef167bc1852e9d0ae72a10a100dc827f43a8bab039cfc8f2e04ee4a.png",c="/learning-notes-blog/images/5740fa0ae6fdaf45e301654585051556d35716c3adf3330ea9fdb91f604cdf2b.png",i="/learning-notes-blog/images/83cb787dc427f88c60a9e57badb8d73d235c52d8320a6cdf566cadac2b464dbf.png",g="/learning-notes-blog/images/ea9ab252d0ef1eea70ca19af3abd3ff7c237516a076c152cf1c2cd67832db1e8.png",m="/learning-notes-blog/images/035206c63b134eb96f1bcb6e7884819f494ad59066b3223ad0f8f3cec9fd11ed.png",v=JSON.parse('{"title":"","description":"js 内存分配 - 内存","frontmatter":{"description":"js 内存分配 - 内存"},"headers":[],"relativePath":"A.前端知识整理/3.浏览器和JS引擎执行过程/6.JS中的堆(Heap)栈(Stack)内存.md","filePath":"A.前端知识整理/3.浏览器和JS引擎执行过程/6.JS中的堆(Heap)栈(Stack)内存.md","lastUpdated":1687956671000}'),d={name:"A.前端知识整理/3.浏览器和JS引擎执行过程/6.JS中的堆(Heap)栈(Stack)内存.md"},B=e('<p>JavaScript 是动态语言，那么什么是静态语音呢，<strong>我们把在运行过程中需要检查数据类型的语言称为动态语言 <code>let a = 1</code></strong>，<strong>在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为静态语言。<code>int a = 1</code></strong></p><p>有些语言，会例如把 bool 类型的变量赋值给数字类型的变量，我们通常把这种偷偷转换的操作称为<strong>隐式类型转换</strong>，<strong>支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言</strong></p><p><img src="'+l+'" alt="图 1"></p><p>因此 js 具备的特点就是一种弱类型的、动态的语言</p><ul><li><strong>弱类型</strong>，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。</li><li><strong>动态</strong>，意味着你可以使用同一个变量保存不同类型的数据。</li></ul><p>知道JavaScript 是什么语言后在来看如何分配内存的。 创建变量、函数等行为的时候JS 引擎会为此分配内存，并在不再需要时释放它，每一次它们都会经历三个阶段 <strong>分配内存</strong> -- <strong>使用内存</strong> -- <strong>释放内存</strong></p><ol><li><p><strong>分配内存</strong>：在JavaScript中，当我们创建变量、函数等对象时，JS引擎会自动为这些对象分配内存空间。这意味着我们不需要手动管理内存分配。</p></li><li><p><strong>使用内存</strong>：使用内存是指我们在代码中对变量进行读取和写入操作。这是我们在编写程序时需要明确处理的部分。</p></li><li><p><strong>释放内存</strong>：当我们不再需要某个对象时，JavaScript引擎会自动释放其占用的内存。这样，这部分内存空间就可以被用于其他目的。这一过程是由JavaScript引擎自动处理的，我们不需要手动进行内存释放。</p></li></ol><p>关于储存的位置JavaScript 引擎有两个地方可以存储数据&#39;堆&#39;和&#39;栈&#39;</p><p><strong>原始类型</strong>占据的空间是在<strong>栈</strong>内存中分配的；<strong>对象类型</strong>占据的空间是在<strong>堆</strong>内存中分配的</p><h2 id="栈-stack" tabindex="-1">栈 -- Stack <a class="header-anchor" href="#栈-stack" aria-label="Permalink to &quot;栈 -- Stack&quot;">​</a></h2><ol><li><p>栈内存是计算机内存中的一部分，由操作系统直接管理。它的大小由操作系统决定，通常比堆内存要小。栈内存主要用于存储基本数据类型（如string、number、bigint、boolean、undefined、null和symbol）和函数调用时的临时数据（如局部变量和函数参数）。</p></li><li><p>基本数据类型和指向对象和函数的引用（内存地址）在栈内存中存储。这些数据的值大小是固定的，编译时就可以确定。因此，在程序执行之前，系统会为这些数据分配固定数量的内存。这种分配内存的方式称为静态内存分配。静态内存分配的优点是内存管理简单，访问速度快；缺点是不适合存储动态变化的数据。</p></li><li><p>null是一种特殊的数据类型，表示空值或没有值。虽然typeof null返回的是&#39;object&#39;，但实际上null并不是一个对象。这是因为JavaScript中的一个历史遗留问题，最初的设计中null被认为是一个特殊的对象值，表示没有对象。后来，虽然null的概念已经发生了变化，但typeof null的返回值仍然保持为&#39;object&#39;</p></li><li><p><strong>栈具有以下特点</strong>：</p><ul><li><strong>操作数据快</strong>：栈内存中的数据操作都是在栈顶进行的，所以速度较快。每次数据入栈或出栈，只需要移动栈顶指针，操作简单高效。</li><li><strong>数据必须是静态的</strong>：栈内存中存储的数据大小在编译时就已经确定，不能动态改变。这意味着栈内存不适合存储动态变化的数据，如数组和对象。</li><li><strong>内存管理简单</strong>：栈内存的管理由操作系统完成，不需要程序员手动管理。操作系统会自动分配和回收栈内存，降低了内存泄漏的风险。</li><li><strong>栈大小有限</strong>：栈内存空间有限，如果数据过多可能会发生栈溢出（Stack Overflow）错误。栈溢出通常是由于递归调用过深或者局部变量过多导致的。为了避免栈溢出，可以使用堆内存存储大量数据或者限制递归调用的深度。</li></ul></li></ol><h3 id="栈的声明过程" tabindex="-1">栈的声明过程 <a class="header-anchor" href="#栈的声明过程" aria-label="Permalink to &quot;栈的声明过程&quot;">​</a></h3><p><code>let myNumber = 23</code> 赋值过程经历三个步骤 储存的空间都在栈中</p><ul><li>为变量创建一个唯一标识符（&#39;myNumber&#39;）。</li><li>在内存中分配一个地址（将在运行时分配）。基本类型（如数字、字符串、布尔值等）也需要在内存中分配地址来存储它们的值</li><li>变量 myNumber 被分配了一个内存地址，该地址用于存储值 (23) 中存储一个值。</li></ul><p><img src="'+p+`" alt="图 1"></p><h3 id="栈的赋值过程" tabindex="-1">栈的赋值过程 <a class="header-anchor" href="#栈的赋值过程" aria-label="Permalink to &quot;栈的赋值过程&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 根据打印结果可以看出虽然myNumber 赋值给 newVar 但 当给myNumbe 加 1的时候并没有影响newVar </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 说明栈基本类型赋值时候是重新开辟了空间</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">myNumber</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">23</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">newVar</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">myNumber</span></span>
<span class="line"><span style="color:#E06C75;">myNumber</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">myNumber</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">myNumber</span><span style="color:#ABB2BF;"> ) </span><span style="color:#7F848E;font-style:italic;">// 24</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">newVar</span><span style="color:#ABB2BF;">  )  </span><span style="color:#7F848E;font-style:italic;">// 23</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>myNumber 虽然赋值给了newVar 但是newVar 依旧在栈中新开辟了自己的空间记录自己</strong></p><p><img src="`+o+`" alt="图 2"></p><p>看字符串的案例</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// js中的原始数据类型，因此将分配新的内存地址，abcd存储在那里，并将mystring指向这个新的内存地址</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">myString</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;abc&#39;</span></span>
<span class="line"><span style="color:#E06C75;">myString</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">myString</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;d&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>当我们给之前变量重新赋值时候如图并不是在之前基础上的地址直接加上&#39;d&#39; 而是开辟了新的地址</strong>,为什么是新开辟地址，在开篇说过栈中的数据有一个共同点。这些数据的大小是固定的，如果从原来的&#39;abc&#39; 内存大小直接变成&#39;abcd&#39; 完全不符合这点相反却变成了动态内存，因此在栈中的每一次变化都是一次新的空间开辟</p><p><img src="`+r+'" alt="图 3"></p><h2 id="堆-heap" tabindex="-1">堆 -- Heap <a class="header-anchor" href="#堆-heap" aria-label="Permalink to &quot;堆 -- Heap&quot;">​</a></h2><p>区分和数据结构堆的概念，内存管理中的堆主要关注动态分配和释放内存，而数据结构中的堆主要关注数据的组织和访问</p><p><strong>数据结构中的堆（Heap）</strong> ：在数据结构中，堆是一种特殊的树形数据结构，通常用于实现优先队列。这种堆满足堆属性，即每个节点的值都大于（或小于）其子节点的值。最常见的堆数据结构是二叉堆（Binary Heap），它是一种完全二叉树，可以用数组表示。</p><p><strong>内存管理中的堆（Heap）</strong> ：在内存管理中，堆是一种动态分配内存的区域，用于存储程序运行时创建的对象和函数。这种堆通常在程序的整个生命周期内存在，并且可以在程序的多个线程之间共享。在这种情况下，堆是与栈（Stack）相对应的内存区域，栈用于存储程序的局部变量和函数调用的上下文。</p><p>堆（Heap）是计算机内存中的一种数据结构，用于存储动态分配的内存。在 JavaScript 中，堆主要用于存储对象和函数。与栈（Stack）相比，堆具有以下特点：</p><ul><li><p><strong>操作速度慢，但容量大</strong>：堆的操作速度相对较慢，因为在堆中查找、分配和释放内存需要更多的时间。然而，堆的容量通常比栈大得多，因此可以存储更多的数据。</p></li><li><p><strong>可以将动态大小的数据存储在此处</strong>：堆中的内存是动态分配的，这意味着在程序运行时可以更改对象的大小。这对于处理不确定大小的数据（如用户输入的数据）非常有用。</p></li><li><p><strong>堆在应用程序的线程之间共享</strong>：堆中的数据可以在应用程序的不同线程之间共享。这使得多个线程可以访问和操作相同的数据，从而实现线程间的通信。</p></li><li><p><strong>堆管理起来比较困难</strong>：由于堆的动态特性，管理堆中的内存分配和释放相对复杂。程序员需要确保正确分配和释放内存，以避免内存泄漏和其他内存管理问题。</p></li><li><p><strong>值大小没有限制</strong>：堆中存储的值没有大小限制，这意味着可以在堆中存储任意大小的对象和函数。这为处理大型数据结构（如图、树等）提供了便利。</p></li></ul><h3 id="堆-变量声明" tabindex="-1">堆 变量声明 <a class="header-anchor" href="#堆-变量声明" aria-label="Permalink to &quot;堆 变量声明&quot;">​</a></h3><p><code>let myArray= []</code> 赋值过程经历四个步骤对 象的引用地址在栈中，数据存在堆中</p><ol><li><p>为变量创建一个唯一标识符（&#39;myArray&#39;），这个标识符将用于在代码中引用这个变量。</p></li><li><p>在内存中分配一个地址，这个地址将用于存储变量的值。这个地址在运行时动态分配。</p></li><li><p>将分配的内存地址指向堆内存。堆内存是用于存储对象和数组等复杂数据类型的内存区域。</p></li><li><p>在内存地址指向的堆内存中存储一个空数组（[]）。这个空间是动态的，意味着数组的大小和内容可以在运行时改变。</p></li></ol><p><strong>如图 myArray 变量声明的表示符号指向栈中一个地址这个地址对应栈中的value 实际是对象堆的内存地址</strong><img src="'+t+`" alt="图 4"></p><h3 id="堆-变量赋值" tabindex="-1">堆 变量赋值 <a class="header-anchor" href="#堆-变量赋值" aria-label="Permalink to &quot;堆 变量赋值&quot;">​</a></h3><p><strong>js原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>，当变量赋值给另一个变量的时候内存地址指向其实是同一个。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">reference</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> [</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">refCopy</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">reference</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">reference</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">push</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="`+c+`" alt="图 5"></p><p>当变量重新赋值时候改变的是内存地址指向</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">first</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;reference&#39;</span><span style="color:#ABB2BF;"> };  </span></span>
<span class="line"><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">second</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;ref2&#39;</span><span style="color:#ABB2BF;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="`+i+'" alt="图 6"></p><h2 id="通过其他的模型图解来看" tabindex="-1">通过其他的模型图解来看 <a class="header-anchor" href="#通过其他的模型图解来看" aria-label="Permalink to &quot;通过其他的模型图解来看&quot;">​</a></h2><p><img src="'+g+'" alt="图 7"></p><p><img src="'+m+'" alt="图 8"></p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://time.geekbang.org/column/intro/100033601?utm_source=pinpaizhuanqu&amp;utm_medium=geektime&amp;utm_campaign=guanwang&amp;utm_term=guanwang&amp;utm_content=0511" target="_blank" rel="noreferrer">浏览器工作原理与实践_李兵</a></p><p><a href="https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0" target="_blank" rel="noreferrer">在 Javascript 中解释值与引用</a></p><p><a href="https://developers.weixin.qq.com/community/minigame/article/doc/000e641c5f0d1862cb8bdbe0c58c13" target="_blank" rel="noreferrer"># JavaScript 内存详解 &amp; 分析指南</a></p><p><a href="https://felixgerschau.com/javascript-memory-management/#conclusion" target="_blank" rel="noreferrer"># JavaScript&#39;s Memory Management Explained</a></p><p><a href="https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239" target="_blank" rel="noreferrer"># JavaScript 的内存模型</a></p><p><a href="https://cdmana.com/2021/09/20210912121834535c.html" target="_blank" rel="noreferrer"># V8中的JavaScript的内存管理与垃圾回收</a></p><p><a href="https://medium.com/@allansendagi/javascript-fundamentals-call-stack-and-memory-heap-401eb8713204" target="_blank" rel="noreferrer">javascript-fundamentals-call-stack-and-memory-heap</a></p><p><a href="https://blog.alexdevero.com/memory-life-cycle-heap-stack-javascript/" target="_blank" rel="noreferrer">memory-life-cycle-heap-stack-javascript/</a></p><p><a href="https://www.javascripttutorial.net/javascript-call-stack/" target="_blank" rel="noreferrer">https://www.javascripttutorial.net/javascript-call-stack/</a></p>',53),y=[B];function b(u,f,h,_,A,F){return s(),n("div",null,y)}const k=a(d,[["render",b]]);export{v as __pageData,k as default};
