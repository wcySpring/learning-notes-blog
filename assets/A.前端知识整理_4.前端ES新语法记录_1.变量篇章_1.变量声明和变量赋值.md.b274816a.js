import{_ as s,o as n,c as a,O as l}from"./chunks/framework.ab95ac3d.js";const e="/learning-notes-blog/images/4ba2f5313c0865ead76c981e494ac72c4acec667d7ccdbc541de23850f280426.png",o="/learning-notes-blog/images/301787261ba9fa6d2e467fa39f660d6803349562329d8536304d69c86a005bf8.png",p="/learning-notes-blog/images/2e66fbd22626eeaf818f6f9725ff8cb5d85d95e0c0c5826ced20e80d76070a3c.png",m=JSON.parse('{"title":"","description":"变量声明和变量赋值 - 变量","frontmatter":{"description":"变量声明和变量赋值 - 变量"},"headers":[],"relativePath":"A.前端知识整理/4.前端ES新语法记录/1.变量篇章/1.变量声明和变量赋值.md","filePath":"A.前端知识整理/4.前端ES新语法记录/1.变量篇章/1.变量声明和变量赋值.md","lastUpdated":1687956671000}'),r={name:"A.前端知识整理/4.前端ES新语法记录/1.变量篇章/1.变量声明和变量赋值.md"},t=l('<p><strong>js 变量声明整体可以分为六种</strong>：</p><ol><li><code>let x</code>-- 声明变量 x。不可在赋值之前读。</li><li><code>const x</code> -- 声明常量 x。不可在赋值之前读,不可写。</li><li><code>var x</code>-- 声明变量 x。在赋值之前可读取到 undefined 值。</li><li><code>function x</code> -- 声明变量 x。该变量指向一个函数。</li><li><code>class x</code> -- 声明变量 x。该变量指向一个类（该类的作用域内部是处理严格模式的）。</li><li><code>import</code> -- 导入标识符并作为常量（可以有多种声明标识符的模式和方法）</li></ol><p><strong>上面的六种大体可以归类为三种情况</strong> <code>var</code>,<code>const</code>,<code>let</code></p><ul><li>属于 <code>var</code> 归类: <code>var</code> 和 <code>function</code> 声明变量，这两种声明方式都会发生变量提升，即在声明之前使用变量会得到 undefined 值，而不会报错。它们的作用域是函数作用域。</li><li>属于 <code>const</code> 归类: <code>const</code> 和 <code>import</code> 声明变量, 这两种声明方式都是常量，不能被重新赋值。在声明前使用会报错。它们的作用域是块级作用域。正是如此也可以更好的解释 <code>import</code> 声明为什么要放到最上面， <code>import</code> 声明的变量是常量，不能被重新赋值，且在声明前就使用会报错。和 <code>const</code> 声明的变量一样，<code>import</code> 声明的变量也是块级作用域。</li><li>属于 <code>let</code> 和 <code>class</code> 声明变量，这两种声明方式都不能在声明前使用，否则会报错。它们的作用域是块级作用域。特别地，<code>class</code> 声明的内部是处于严格模式中的。</li></ul><p><strong>要注意一个强调的变量声明,声明和语句是编程中两个不同的概念</strong></p><p><strong>声明是用来告诉编译器某个变量的类型和名称</strong>，以便在编译时分配内存空间。<strong>声明发生在编译期</strong>，编译器会为所声明的变量在相应的变量表中增加一个名字。</p><p><strong>语句是用来执行某些操作的代码，例如赋值、条件判断、循环等</strong>。声明和语句的区别在于它们发生的时间点不同。<strong>语句是在运行期执行的程序代码</strong>，需要CPU来执行。如果声明不带初始化，编译器可以完全处理，不会产生运行时执行的代码，因为编译器已经知道了变量的类型和名称，可以在编译时分配内存空间。</p><p><strong>JavaScript 将可以通过 静态 语法分析发现那些声明的标识符</strong>；在变量声明阶段，JavaScript引擎会为变量分配内存空间，并将变量绑定到该内存空间。</p><p>对于使用var关键字声明的变量，它们的初始值会被设置为undefined；对于使用let和const关键字声明的变量，它们在声明阶段不会被赋值。</p><p>因此标识符对应的变量 / 常量（let var 声明的就是变量可以重新赋值，const 属于常量） <strong>一定</strong> 会在用户代码执行前就已经被创建在作用域中（也就是声明阶段）。</p><h2 id="js-变量声明赋值过程" tabindex="-1">js 变量声明赋值过程 <a class="header-anchor" href="#js-变量声明赋值过程" aria-label="Permalink to &quot;js 变量声明赋值过程&quot;">​</a></h2><p><strong>举个例子 <code>var myArray= []</code> 赋值过程经历步骤</strong></p><ol><li><p><strong>变量声明</strong>：在编译阶段（声明），JavaScript 引擎会为变量 <code>myArray</code> 进行声明。此时，变量尚未赋值，其值为 <code>undefined</code>。</p></li><li><p><strong>变量赋值</strong>：在执行阶段（语句），JavaScript 引擎会创建一个空数组对象 <code>[]</code>。这个对象会被存储在堆内存中，同时分配一个内存地址。</p></li><li><p><strong>将内存地址赋值给变量</strong>：将存储空数组对象的内存地址赋值给变量 <code>myArray</code>。这样，<code>myArray</code> 就指向了空数组对象。</p></li><li><p><strong>动态调整</strong>：由于 JavaScript 是一种动态语言，数组的大小和内容可以在运行时动态调整。当向数组中添加或删除元素时，内存中的空间会相应地进行调整。</p></li></ol><p><img src="'+e+`" alt="图 1"></p><h2 id="对比来看静态语言声明赋值过程" tabindex="-1">对比来看静态语言声明赋值过程 <a class="header-anchor" href="#对比来看静态语言声明赋值过程" aria-label="Permalink to &quot;对比来看静态语言声明赋值过程&quot;">​</a></h2><p><strong>在静态语言（如 C++、Java 等）中，变量的类型和初始值在编译阶段就已经确定</strong>。这与动态语言（如 JavaScript）有所不同，动态语言在运行时才会为变量分配内存和赋值。<code>int[] myArray = []</code> 这个语句在静态语言（如 Java）中为例</p><ol><li><p><strong>变量声明与类型</strong>：int[] myArray 声明了一个整型数组变量 myArray。这意味着 myArray 只能存储整数类型的元素。</p></li><li><p><strong>变量赋值</strong>：int[] myArray = [] 语句在 <strong>编译阶段(声明时候)</strong> 为 myArray 分配内存并初始化为空数组。这意味着 myArray 的长度为 0，没有任何元素。</p></li><li><p><strong>内存管理</strong>：在静态语言中，数组的大小通常是固定的。如果需要改变数组的大小，需要创建一个新的数组并将原数组的元素复制到新数组中。在 Java 中，可以使用 System.arraycopy() 方法实现这一功能。</p></li><li><p><strong>类型安全</strong>：由于静态语言在编译阶段就确定了变量的类型，因此具有更强的类型安全。在本例中，myArray 只能存储整数类型的元素，如果尝试向其中添加其他类型的元素，编译器会报错。</p></li></ol><p>静态语言在编译阶段就确定了变量的类型和初始值，这使得程序在执行过程中具有更高的确定性和性能。然而，这也意味着静态语言的灵活性相对较低，因为在运行时不能轻易地改变变量的类型和内存空间。</p><h2 id="var-x-y-100-发生什么" tabindex="-1">var x = y = 100 发生什么 <a class="header-anchor" href="#var-x-y-100-发生什么" aria-label="Permalink to &quot;var x = y = 100 发生什么&quot;">​</a></h2><p>结合上面，要知道 js 两个阶段 <strong>声明</strong> 和 <strong>语句运行</strong> ， <strong><code>var/let/const</code>声明</strong> 和 <strong>语句运行的赋值阶段不同</strong></p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {} </span><span style="color:#7F848E;font-style:italic;">// 这是 var 声明</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">b</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">10</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">// 这是语句运行的赋值</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><code>var/let/const</code><strong>声明语句中的等号左边，绝不可能是一个表达式</strong>。声明阶段一定是发生在<strong>编译期</strong></p><p>因此，根本上来说，在 var 声明 语法中，变量名位置上就是写不成a.x的</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">.x </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> ...   </span><span style="color:#7F848E;font-style:italic;">// &lt;- 这里将导致语法出错</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在看这个案例 <code>var x</code> 在 <strong>声明阶段也就是编译期间就已经存在了</strong></p><p>但 此时 y 变量并没有被声明定义 （<strong>在当前作用域（scope）中没有被声明使用var、let或const关键字定义的变量</strong>），<strong>将赋值给未声明变量（let/const/var）的值在执行赋值时将其隐式地创建为全局变量</strong> 这种变量也叫做<strong>隐式全局变</strong></p><p><strong>声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建</strong>。通过下面代码可以证明 var x 是在声明阶段 ，而 y 是在运行阶段</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 非声明 变量隐式全局变量如果没有上来赋值就报错</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">);                </span><span style="color:#7F848E;font-style:italic;">// 抛出ReferenceError。</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;still going...&#39;</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 永不执行。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// var 这中声明变量就不会有这个问题</span></span>
<span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">);                </span><span style="color:#7F848E;font-style:italic;">// 打印&quot;undefined&quot;或&quot;&quot;（不同浏览器实现不同）。</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;still going...&#39;</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 打印&quot;still going...&quot;。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>也通过 <code>getOwnPropertyDescriptor</code> 来验证 <code>configurable</code> 如果是true 怎说明是一个隐式全局变量 为false 则是一个声明</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">100</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getOwnPropertyDescriptor</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">window</span><span style="color:#ABB2BF;">,</span><span style="color:#98C379;">&#39;y&#39;</span><span style="color:#ABB2BF;">))</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">getOwnPropertyDescriptor</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">window</span><span style="color:#ABB2BF;">,</span><span style="color:#98C379;">&#39;x&#39;</span><span style="color:#ABB2BF;">))</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#E06C75;">打印结果</span><span style="color:#ABB2BF;">：</span></span>
<span class="line"><span style="color:#ABB2BF;">{value: </span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;">, writable: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">, enumerable: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">, configurable: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#ABB2BF;">{value: </span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;">, writable: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">, enumerable: </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">, configurable: </span><span style="color:#D19A66;">false</span><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">100</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>因此整个过程可以拆解为，因此并不推荐这种连续赋值</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 变量提升声明 x</span></span>
<span class="line"><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">// 隐式全局变量在特定情况下会出现泄漏</span></span>
<span class="line"><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">// 变量赋值</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;">y</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#E06C75;">打印结果</span><span style="color:#ABB2BF;">：</span></span>
<span class="line"><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">100</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这种隐士变量的好处代码中不需要显式地声明一个变量了，变量可以随用随声明，也不用像后来的let语句一样，还要考虑在声明语句之前能不能访问的问题了。相对的也会出现一个问题 <strong>变量泄漏</strong>，在少量的代码中也相当易用。但是，如果代码规模扩大，变成百千万行代码，可能因为忘记本地的声明而读写了全局变量，不方便调试</p><p>还是要特别强调要注意 ，声明和赋值的区别他们完全是在两个阶段，<code>var/let/const</code><strong>声明语句中的等号左边，绝不可能是一个表达式</strong> ， var/let/const 关键字只负责声明变量名，而不是进行赋值操作，他的过程属于 <strong>初始器（Initializer）</strong>，初始器是用来在声明变量时给变量赋予初始值的。<strong>在初始器中，&quot;=&quot; 号不是一个运算符，而是一个语法分隔符,用于将变量名与其初始值关联起来</strong>。所以，虽然初始器看起来像是一个赋值操作，但实际上它并不是一个严格意义上的赋值操作。</p><blockquote><p>Initializer: = AssignmentExpression</p></blockquote><p>在 &quot;var x = 100&quot; 这个语句中，&quot;var x&quot; 是创建变量名的部分，而 &quot;= 100&quot; 是给变量 x 赋初始值的部分。x 只是一个表达名字的、静态语法分析期作为标识符来理解的字面文本，而不是一个表达式。</p><ul><li>用 &quot;var&quot;、&quot;let&quot; 或 &quot;const&quot; 关键字创建变量时，这些关键字的作用是告诉 JavaScript 我们要创建一个变量，而不是给变量赋值。</li><li>当我们创建变量的同时给它赋一个初始值，这个过程叫做 &quot;初始器&quot;。在这个过程中，&quot;=&quot; 号的作用是把初始值和变量关联起来，而不是进行数学运算。</li></ul><p>因此ECMAScript 6 之后的模板赋值的左侧也不是表达式，只要是声明语句中，那么就 不是</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> [</span><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">,</span><span style="color:#E5C07B;">b</span><span style="color:#ABB2BF;">] </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> [</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">,</span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">] </span><span style="color:#7F848E;font-style:italic;">// 左侧不是表单式</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>也可以说 并没有连续声明，var x 是声明 y 是赋值，关于赋值可以参考下面</p><h2 id="赋值" tabindex="-1">赋值 <a class="header-anchor" href="#赋值" aria-label="Permalink to &quot;赋值&quot;">​</a></h2><p>看完了变量声明在来<strong>看赋值操作</strong>， <strong>js 的赋值操作也并不是单纯的</strong> <code>变量名 = 值</code></p><p>整个赋值的过程在规范中来看是 <code>LeftHandSideExpression = AssignmentExpression</code>,也就是将右<strong>操作数</strong>（的值）赋给左<strong>操作数</strong>（的引用）,<strong>操作数既可以是值也可以是字面量。因此 JavaScript 中，一个赋值表达式的左边和右边其实都是表达式</strong>！ 可以 参考 <a href="https://tc39.es/ecma262/#sec-assignment-operators" target="_blank" rel="noreferrer">规范ECMAScript Language Specification sec-assignment-operators</a></p><p>赋值是语句执行时候过程，因此左侧可以作为表达式</p><h3 id="lefthandsideexpression-和-assignmentexpression" tabindex="-1">LeftHandSideExpression 和 AssignmentExpression <a class="header-anchor" href="#lefthandsideexpression-和-assignmentexpression" aria-label="Permalink to &quot;LeftHandSideExpression 和 AssignmentExpression&quot;">​</a></h3><p>具体来看规范中对 LeftHandSideExpression 和 AssignmentExpression 的解释</p><ol><li><p><strong><a href="https://tc39.es/ecma262/#prod-LeftHandSideExpression" target="_blank" rel="noreferrer">LeftHandSideExpression(左表达式)</a></strong> ，在规范中对 <code>LeftHandSideExpression</code> 可以是以下三种类型之一</p><ul><li><p><a href="https://tc39.es/ecma262/#prod-NewExpression" target="_blank" rel="noreferrer">NewExpression</a> ：包含 <code>MemberExpression[?Yield, ?Await]</code> 的定义比较多可以<a href="https://tc39.es/ecma262/#prod-MemberExpression" target="_blank" rel="noreferrer">参考</a> 但是举一个例子 a.b 这种对象属性形式 和 <code>new NewExpression[?Yield, ?Await]</code> 使用 new 关键字创建一个对象实例。例如，new MyClass()</p></li><li><p><a href="https://tc39.es/ecma262/#prod-CallExpression" target="_blank" rel="noreferrer">CallExpression</a>：这是一个用于调用函数的表达式。?Yield和?Await表示在这个表达式中是否允许使用yield和await关键字。</p></li><li><p><a href="https://tc39.es/ecma262/#prod-OptionalExpression" target="_blank" rel="noreferrer">OptionalExpression</a> ：这是一个可选链表达式，用于访问对象属性或调用方法，如果对象或属性不存在，则返回undefined。?Yield和?Await表示在这个表达式中是否允许使用yield和await关键字</p></li></ul></li><li><p><strong><a href="https://tc39.es/ecma262/#prod-AssignmentExpression" target="_blank" rel="noreferrer">AssignmentExpression</a>[In, Yield, Await]</strong>: 赋值表达式是将一个值分配给一个左手边表达式的表达式 在规范里面定义</p><ul><li><a href="https://tc39.es/ecma262/#prod-ConditionalExpression" target="_blank" rel="noreferrer">ConditionalExpression</a>[?In, ?Yield, ?Await][+Yield]</li><li><a href="https://tc39.es/ecma262/#prod-YieldExpression" target="_blank" rel="noreferrer">YieldExpression</a>[?In, ?Await]</li><li><a href="https://tc39.es/ecma262/#prod-ArrowFunction" target="_blank" rel="noreferrer">ArrowFunction</a>[?In, ?Yield, ?Await]</li><li><a href="https://tc39.es/ecma262/#prod-AsyncArrowFunction" target="_blank" rel="noreferrer">AsyncArrowFunction</a>[?In, ?Yield, ?Await]</li><li><a href="https://tc39.es/ecma262/#prod-LeftHandSideExpression" target="_blank" rel="noreferrer">LeftHandSideExpression</a>[?Yield, ?Await]=<a href="https://tc39.es/ecma262/#prod-AssignmentExpression" target="_blank" rel="noreferrer">AssignmentExpression</a>[?In, ?Yield, ?Await]</li><li><a href="https://tc39.es/ecma262/#prod-LeftHandSideExpression" target="_blank" rel="noreferrer">LeftHandSideExpression</a>[?Yield, ?Await]<a href="https://tc39.es/ecma262/#prod-AssignmentOperator" target="_blank" rel="noreferrer">AssignmentOperator</a><a href="https://tc39.es/ecma262/#prod-AssignmentExpression" target="_blank" rel="noreferrer">AssignmentExpression</a>[?In, ?Yield, ?Await]</li><li><a href="https://tc39.es/ecma262/#prod-LeftHandSideExpression" target="_blank" rel="noreferrer">LeftHandSideExpression</a>[?Yield, ?Await]&amp;&amp;=<a href="https://tc39.es/ecma262/#prod-AssignmentExpression" target="_blank" rel="noreferrer">AssignmentExpression</a>[?In, ?Yield, ?Await]</li><li><a href="https://tc39.es/ecma262/#prod-LeftHandSideExpression" target="_blank" rel="noreferrer">LeftHandSideExpression</a>[?Yield, ?Await]||=<a href="https://tc39.es/ecma262/#prod-AssignmentExpression" target="_blank" rel="noreferrer">AssignmentExpression</a>[?In, ?Yield, ?Await]</li><li><a href="https://tc39.es/ecma262/#prod-LeftHandSideExpression" target="_blank" rel="noreferrer">LeftHandSideExpression</a>[?Yield, ?Await]??=<a href="https://tc39.es/ecma262/#prod-AssignmentExpression" target="_blank" rel="noreferrer">AssignmentExpression</a>[?In, ?Yield, ?Await]</li></ul></li></ol><p><a href="https://tc39.es/ecma262/#prod-AssignmentOperator" target="_blank" rel="noreferrer">AssignmentOperator</a>:one of <code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |= **=</code></p><p>对上述规则的解释：</p><ol><li><code>ConditionalExpression[?In, ?Yield, ?Await]</code>：条件表达式，通常用于三元操作符（<code>condition ? expression1 : expression2</code>），根据条件选择执行哪个表达式。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 三元表达案例</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">age</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">18</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">isAdult</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">age</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&gt;=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">18</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">?</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;成年&#39;</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">:</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;未成年&#39;</span><span style="color:#ABB2BF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol><li><code>[+Yield] YieldExpression[?In, ?Await]</code>：Yield表达式，用于生成器函数中暂停和恢复执行。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">function*</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">generator</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">yield</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">yield</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">yield</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">iter</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">generator</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">iter</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">next</span><span style="color:#ABB2BF;">()); </span><span style="color:#7F848E;font-style:italic;">// 输出：{ value: 1, done: false }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol start="3"><li><code>ArrowFunction[?In, ?Yield, ?Await]</code>：箭头函数，一种简洁的函数表达式，使用<code>=&gt;</code>符号定义。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">a</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">b</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">b</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">4</span><span style="color:#ABB2BF;">)); </span><span style="color:#7F848E;font-style:italic;">// 输出：7</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="4"><li><code>AsyncArrowFunction[?In, ?Yield, ?Await]</code>：异步箭头函数，一种支持异步操作的箭头函数。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">fetchData</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">async</span><span style="color:#ABB2BF;"> () </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">response</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">await</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">fetch</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;https://api.example.com/data&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">data</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">await</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">response</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">json</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">data</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"><span style="color:#61AFEF;">fetchData</span><span style="color:#ABB2BF;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="5"><li><code>LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]</code>：基本赋值操作，使用<code>=</code>符号将右侧表达式的值赋给左侧变量。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">10</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 输出：10</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="6"><li><code>LeftHandSideExpression[?Yield, ?Await] AssignmentOperator AssignmentExpression[?In, ?Yield, ?Await]</code>：复合赋值操作，如<code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |= **=</code>等，将左侧变量与右侧表达式的值进行操作后重新赋值给左侧变量。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">b</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">5</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">b</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">b</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 输出：8</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="7"><li><code>LeftHandSideExpression[?Yield, ?Await] &amp;&amp;= AssignmentExpression[?In, ?Yield, ?Await]</code>：逻辑与赋值操作，仅当左侧变量为真时，将右侧表达式的值赋给左侧变量。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">c</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">c</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&amp;&amp;=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">false</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">c</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 输出：false</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="8"><li><code>LeftHandSideExpression[?Yield, ?Await] ||= AssignmentExpression[?In, ?Yield, ?Await]</code>：逻辑或赋值操作，仅当左侧变量为假时，将右侧表达式的值赋给左侧变量。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">d</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">d</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">||=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">10</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">d</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 输出：10</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="9"><li><code>LeftHandSideExpression[?Yield, ?Await] ??= AssignmentExpression[?In, ?Yield, ?Await]</code>：空值合并赋值操作，仅当左侧变量为<code>null</code>或<code>undefined</code>时，将右侧表达式的值赋给左侧变量。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">e</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">null</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E06C75;">e</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">??=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;default&#39;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">e</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// 输出：&#39;default&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="对lefthandsideexpression-assignmentexpression-详细说明" tabindex="-1">对LeftHandSideExpression = AssignmentExpression 详细说明 <a class="header-anchor" href="#对lefthandsideexpression-assignmentexpression-详细说明" aria-label="Permalink to &quot;对LeftHandSideExpression = AssignmentExpression 详细说明&quot;">​</a></h3><p><code>LeftHandSideExpression[?Yield, ?Await] = AssignmentExpression[?In, ?Yield, ?Await]</code> AssignmentExpression 是一个递归操作 注意 上面说到的 AssignmentExpression 表达的含义有九种，因此 所分配解答最开始 解释的 js 并不是简单的 值赋值操作</p><p>这里对 ?In 做个说明这个参数表示表达式是否在in操作符的上下文中。in操作符用于检查对象是否具有某个属性。例如：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;value&quot;</span><span style="color:#ABB2BF;"> };</span></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">result</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;key&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">in</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">obj</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// result为true，因为obj具有&quot;key&quot;属性</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="补充一个知识点" tabindex="-1">补充一个知识点 <a class="header-anchor" href="#补充一个知识点" aria-label="Permalink to &quot;补充一个知识点&quot;">​</a></h3><p>在上面的左侧表达是里，知道左侧其实可以是一个 new 对象 但实际 <code>new Object = 1;</code> 赋值报错( Invalid left-hand side in assignment)<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_assignment_left-hand_side" target="_blank" rel="noreferrer">参考1</a>，<a href="https://stackoverflow.com/questions/3709866/whats-a-valid-left-hand-side-expression-in-javascript-grammar" target="_blank" rel="noreferrer">参考2</a></p><ul><li><a href="https://tc39.es/ecma262/#prod-CallExpression" target="_blank" rel="noreferrer">CallExpression</a> ：包含函数调用。例如，myFunction() 或者 myFunction.a 更多定义。</li><li><a href="https://tc39.es/ecma262/#prod-OptionalExpression" target="_blank" rel="noreferrer">OptionalExpression</a> ：使用可选链操作符（?.）检查对象属性或方法的存在。例如，obj?.prop。</li></ul><p>最主要的还是要看<a href="https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation" target="_blank" rel="noreferrer">规范中的介绍</a><img src="`+o+`" alt="图 1"></p><p><strong>赋值表达式：LeftHandSideExpression = AssignmentExpression</strong></p><ol><li><p>如果左边的表达式（LeftHandSideExpression）既不是一个对象字面量（ObjectLiteral）也不是一个数组字面量（ArrayLiteral），如果赋值操作符左边的表达式既不是对象字面量也不是数组字面量，那么它可能是一个变量名、函数调用、成员访问等其他类型的表达式那么：</p><p>a. 计算左边的表达式并将结果存储在lref中（首先计算赋值操作符左边的表达式的值，并将这个值存储在一个叫做lref的地方）。</p><pre><code> b. 如果赋值表达式（AssignmentExpression）是一个匿名函数定义，并且左边的表达式是一个标识符引用，即赋值操作符右边的表达式是一个匿名函数，并且左边的表达式是一个**变量名**。在这种情况下，JavaScript会使用左边的变量名作为匿名函数的名字那么： 
  i. 使用lref.[[ReferencedName]]作为参数，对赋值表达式进行命名评估，并将结果存储在rval中。
 c. 否则： 
   i. 计算赋值表达式并将结果存储在rref中。
   ii. 获取rref的值并将结果存储在rval中。 
 d. 将rval的值赋给lref。 
 e. 返回rval的值。
</code></pre></li><li><p>让assignmentPattern成为由左边的表达式所覆盖的赋值模式。</p></li><li><p>计算赋值表达式并将结果存储在rref中。</p></li><li><p>获取rref的值并将结果存储在rval中。</p></li><li><p>使用rval作为参数，对assignmentPattern进行解构赋值评估。</p></li><li><p>返回rval的值。</p></li></ol><p><a href="https://tc39.es/ecma262/#prod-ObjectLiteral" target="_blank" rel="noreferrer">ObjectLiteral</a> （对象字面量）也不是 ArrayLiteral（数组字面量）,这里和 我们的情况还是不一样 <code>new Object = 1;</code> 中 <code>new Object</code> 并不是字面量，他所拦截的错误案例在</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 这是一个不正确的示例，因为我们试图将值赋给一个对象字面量</span></span>
<span class="line"><span style="color:#ABB2BF;">{ key: </span><span style="color:#98C379;">&quot;value1&quot;</span><span style="color:#ABB2BF;"> } </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> { </span><span style="color:#E06C75;">key</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;value2&quot;</span><span style="color:#ABB2BF;"> };</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>报错信息 <code>Uncaught SyntaxError: Unexpected token &#39;=&#39;</code> 也和 我们的报错信息 <code>Invalid left-hand side in assignment</code> 在苹果电脑执行<code>Left side of assignment is not a reference.</code> 也不同实际报错位置发生在 <a href="https://tc39.es/ecma262/#sec-putvalue" target="_blank" rel="noreferrer">PutValue（lref，rval）</a>。在PutValue操作的情况下，如果V不是引用记录，容易导致对不存在的属性或值进行赋值或访问。因此，在这个步骤中，会抛出一个ReferenceError异常，表示这是一个错误的引用，程序无法正常执行。简单地说，这是一种防止程序员犯错的保护措施，确保代码的正确性。</p><h2 id="a-x-a-n-2" tabindex="-1"><code>a.x = a ={n:2}</code> <a class="header-anchor" href="#a-x-a-n-2" aria-label="Permalink to &quot;\`a.x = a ={n:2}\`&quot;">​</a></h2><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {}</span></span>
<span class="line"><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">{</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;">// undefined</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>简化赋值规范再来看这个问题</p><ol><li><p>Let lref be the result of evaluating LeftHandSideExpression.</p></li><li><p>Let rref be the result of evaluating AssignmentExpression.</p></li><li><p>Let rval be ? GetValue(rref).</p></li><li><p>Perform ? PutValue(lref, rval).</p></li><li><p>Return rval.</p></li></ol><p>这个代码是从左到右解析的，但赋值过程是从右到左，下面打印的结果 <code>Evaluating the left16 side / Evaluating the left6 side /Evaluating the right2 side </code> 虽然做了运算正常来说算除法 但实际并不是 是先从左到右解析 然后在根据规范计算先除法在加法</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">echo</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">name</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">num</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;Evaluating the &quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">name</span><span style="color:#56B6C2;">+</span><span style="color:#E06C75;">num</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot; side&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">num</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 注意这里的除法运算符 (/)</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">echo</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;left&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">16</span><span style="color:#ABB2BF;">)</span><span style="color:#56B6C2;">+</span><span style="color:#61AFEF;">echo</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;left&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">6</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">/</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">echo</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;right&quot;</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>打印结果</p><p>因此按照规范来看 <strong>LeftHandSideExpression = AssignmentExpression</strong> 注意之前说过 <strong>AssignmentExpression</strong> 是一个递归表达，因此<code>a.x = a ={n:2}</code> 应该拆解为 <code>a.x = (a = {n:2})</code> 也就是 <strong>LeftHandSideExpression =（ LeftHandSideExpression = AssignmentExpression）</strong></p><p>按照规范来说第一步<strong>计算左边的表达式并将结果存储在lref中（首先计算赋值操作符左边的表达式的值，并将这个值存储在一个叫做lref的地方）</strong>，此时被保存起来的 a.x 指向的是 还有进行操作的 我们这里叫 <code>最初a</code> 值是空对象，再来看 后面<code>a = {n:2}</code> 这里的 a 虽然也是 <code>最初a</code> 值是空对象,但因为被赋值的原因此时 a 已经变成了 <code>新a</code> <code>{n:2}</code>,现在就可以拆解为 <code> a.x = {n:2}</code> 注意此时 a.x a是<code>最初a</code>，也就是 <code>PutValue({}, {n:2})</code> 在最初的 a上赋值了 对新的没有影响</p><p>所以，当你执行 console.log(a.n) 时，输出的是 2，因为这是新对象的n属性的值。而当你执行 console.log(a.x) 时，输出的是 undefined，因为在新对象上并没有x属性，x属性是在原来的对象上，但是原来的对象已经被新的对象替代了，所以无法访问到。</p><ul><li>图从左到右看，绿色代表 <code>最初a</code> 红色表示 <code>新a</code><img src="`+p+`" alt="图 1"></li></ul><p>通过步骤还原</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {}</span></span>
<span class="line"><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">{</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 此时 a.x  中的a 指向 var a ={} 并且存在了一个空间中</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// a = {n:2} 的 a 原本也是 var a = {} 但将 此时 a 进行了重新赋值 var a 变成了 a ={n:2}</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 注意此时 a.x 虽然指向是 var a = {} 并且 新的 var a ={n:2}但是 在左边表达式时候 原 var a ={} 已经保存了</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// a.x =&gt; {} =&gt; {} = {n:2},现在 在原始的 a 上 a.x = {n:2} 但新 a 上还是 {n:2} 没有 x 属性  </span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 下面打印的是谁 实际是新 a</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;">// 2</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">) </span><span style="color:#7F848E;font-style:italic;">// undefined</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li>证明上面说的，我们用ref 保存我们说的最初 a，执行代码后</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// ref 保存的是上一次的a</span></span>
<span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">}, </span><span style="color:#E06C75;">ref</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">};</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// --&gt; undefined</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">ref</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">// {n:2}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>另一种证明方法，第二次赋值操作中，将尝试向“原始的变量a”添加一个属性“a.x“，且如果它没有冻结的话，属性 <code>a.x</code> 会指向第一次赋值的结果</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 声明“原始的变量a”</span></span>
<span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 使它的属性表冻结（不能再添加属性）</span></span>
<span class="line"><span style="color:#E5C07B;">Object</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">freeze</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">try</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 本节的示例代码</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">:</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">};</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">catch</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 异常发生，说明第二次赋值“a.x = ...”中操作的\`a\`正是原始的变量a</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;第二次赋值导致异常.&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 第一次赋值是成功的</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">); </span><span style="color:#7F848E;font-style:italic;">//</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>换个角度通过运算符优先级角度来看</strong></p><p>其中 赋值<code>=</code>优先级别是 2 ，成员访问<code>.</code>是18,运算符优先级越大优先级越高。想了解更多的同学可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noreferrer">MDN。</a></p><p>由于访问成员.的优先级大于赋值的优先级，所以赋值时这样的：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">转为:</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;">a</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">x</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">};</span></span>
<span class="line"><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span><span style="color:#E06C75;">n</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://time.geekbang.org/column/intro/100033601?utm_source=pinpaizhuanqu&amp;utm_medium=geektime&amp;utm_campaign=guanwang&amp;utm_term=guanwang&amp;utm_content=0511" target="_blank" rel="noreferrer">浏览器工作原理与实践_李兵</a></p><p><a href="https://www.codetd.com/article/13478306" target="_blank" rel="noreferrer">一道阿里面试题引起的思考：var foo = {n: 1}; var bar = foo; foo.x = foo = {n: 2};</a></p><p><a href="https://time.geekbang.org/column/article/165985" target="_blank" rel="noreferrer"> a.x = a = {n:2}：一道被无数人无数次地解释过的经典面试题</a></p><p><a href="https://time.geekbang.org/column/article/165198" target="_blank" rel="noreferrer">var x = y = 100：声明语句与语法改变了JavaScript语言核心性质</a></p>`,106),c=[t];function i(B,y,d,A,F,u){return n(),a("div",null,c)}const g=s(r,[["render",i]]);export{m as __pageData,g as default};
