import{_ as t,o as e,c as r,O as a}from"./chunks/framework.ab95ac3d.js";const o="/learning-notes-blog/images/0b5d096a46e60d66dfbd1075f00ab8b68e8375e702eeff46e724f76d8f5376e9.png",i="/learning-notes-blog/images/054e247171aa91a5a17a64877a1abd4688b29a4f074cf2bb9138ef6a7aee6ef5.png",s="/learning-notes-blog/images/e0c1620070ae9b79f1e9503a265a30a18b6d0646a30aaf2eb8a3a698de32979b.png",l="/learning-notes-blog/images/d8a050630251ca387435d25767012fe8ddbda3b77ce1c0e9f4826db34c2154f0.png",n="/learning-notes-blog/images/80a05e963d46c50c8413cc44b31a116e4dd6c3d722668edbf069d5f0db24a311.png",p="/learning-notes-blog/images/56f0f9be8c2be293e11732f2d9cbd624ef00d40af1e8d53bcb9835c982507a90.png",d="/learning-notes-blog/images/7e12e4f23447c0a5e876e087d0e9113a5892bf3c996a84d399842646748a110e.png",c="/learning-notes-blog/images/ad25c2f00bf3e047667740c9d0b52f77fdb2e593acfda69598ace43034a76542.png",g="/learning-notes-blog/images/4287add06ad838b9bec1ab21f2f3d6ccf7af95ecf2049b47c1dbfa43d557f1da.png",b="/learning-notes-blog/images/5a7de4e95780795ead27d2de74ef3a6c496bfb91457273f5ece04614b473beb6.png",h="/learning-notes-blog/images/87d1a9af38560d12cb77503605dc4115efa6d1c10f43387b5f49711c1e206ef9.png",m="/learning-notes-blog/images/301f384eb05e8992f835e1f413f34bc124059e4418b6e11b4d520763df26ebf9.png",S="/learning-notes-blog/images/e5b830c5fae528813860606fe6724fe5cfdd69daaebfa33f3e77bfa378efa791.png",f="/learning-notes-blog/images/a8d471c89ac38b1e833f45892b3f723e527f743a0d2d9fe3fae41a482701d25f.png",u="/learning-notes-blog/images/08a9f60a3ec1383fc38171fba6642462d217dd37097d8ecf107250bacf1c4a91.png",M="/learning-notes-blog/images/75cc90dcf05748008281eed391dcbcd7aba3c3076f60eb1dc133e83b877d9c15.png",C="/learning-notes-blog/images/e9ad2f22271c3df888f9b86840f58bd9d6f1eb7f7ccb117795d1c4749fe387cb.png",A=JSON.parse('{"title":"","description":"浏览器代码执行的基础概念 -  浏览器代码执行过程","frontmatter":{"description":"浏览器代码执行的基础概念 -  浏览器代码执行过程"},"headers":[],"relativePath":"A.前端知识整理/3.浏览器和JS引擎执行过程/2.浏览器执行过程概念了解.md","filePath":"A.前端知识整理/3.浏览器和JS引擎执行过程/2.浏览器执行过程概念了解.md","lastUpdated":1687795930000}'),T={name:"A.前端知识整理/3.浏览器和JS引擎执行过程/2.浏览器执行过程概念了解.md"},_=a('<p>js 引擎需要容器才能执行，这个章节通过浏览器容器来看 整个执行过程</p><p><strong>js 作为高级语言（解释型语言）</strong>，在执行过程中需要将<strong>源码转换成字节码等中间代码或者是机器码</strong>，这个让cpu 识别 js 语言的过程通常会交给js 引擎，我们常说的引擎都有Chrome V8引擎 (chrome、Node、Opera、Edge）、SpiderMonkey （Firefox）Nitro (Safari）、Chakra （Edge)</p><p><strong>JS 引擎（单线程）往往不是单独运行的</strong> 它运行在一个宿主环境中，对于大多数开发者来说就是典型的<strong>浏览器和 Node.js</strong></p><h2 id="浏览器容器" tabindex="-1">浏览器容器 <a class="header-anchor" href="#浏览器容器" aria-label="Permalink to &quot;浏览器容器&quot;">​</a></h2><p><img src="'+o+'" alt="图 14"></p><p>以谷歌浏览器为例 作为作为<strong>多进程</strong>的容器， 点击 Chrome 浏览器右上角的 &quot;选项&quot; 菜单，选择 &quot;更多工具&quot; 子菜单，点击 &quot;任务管理器&quot; 或者&quot;shift + Esc&quot;打开chrome的<strong>任务管理器</strong>，可以看到一个tab 页占用一个进,并且还有一些浏览器默认进程</p><p><img src="'+i+'" alt="图 15"></p><p>上图中的Chrome 进程架构，包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p><ol><li><p><strong>浏览器进程</strong>：浏览器进程是整个浏览器的主进程，负责协调和管理其他进程。它主要执行以下任务：</p><ul><li>界面显示：负责渲染浏览器的用户界面，如地址栏、书签栏、菜单栏等。</li><li>用户交互：处理用户的输入，如点击、滚动、键盘输入等。</li><li>子进程管理：创建、监控和终止其他进程，如渲染进程、GPU 进程等。</li><li>存储管理：负责浏览器的存储功能，如 Cookie、缓存、历史记录等。</li></ul></li><li><p><strong>渲染进程</strong>：渲染进程负责将网页代码（HTML、CSS、JavaScript）转换成可视化的网页。它主要执行以下任务：</p><ul><li>HTML 解析：将 HTML 代码解析成 DOM（文档对象模型）树。</li><li>CSS 解析：将 CSS 代码解析成 CSSOM（CSS 对象模型）树。</li><li>渲染树构建：将 DOM 树和 CSSOM 树合并成渲染树。</li><li>布局：计算渲染树中每个元素的位置和大小。</li><li>绘制：将渲染树中的元素绘制到屏幕上。</li><li>JavaScript 执行：运行 JavaScript 代码，实现网页的交互功能。</li></ul></li><li><p><strong>GPU 进程</strong>：GPU 进程负责处理图形和图像的渲染。它主要执行以下任务：</p><ul><li>3D 渲染：使用 WebGL 技术实现 3D 图形渲染。</li><li>2D 渲染：使用 Canvas 2D 技术实现 2D 图形渲染。</li><li>硬件加速：利用 GPU 的并行计算能力，加速网页和浏览器界面的渲染。</li><li>视频解码：使用 GPU 进行高效的视频解码，降低 CPU 负载。</li></ul></li><li><p><strong>网络进程</strong>：网络进程负责处理网页的网络资源加载。它主要执行以下任务：</p><ul><li>资源请求：向服务器发送请求，获取网页所需的资源，如图片、CSS、JavaScript 等。</li><li>数据接收：接收服务器返回的资源数据，并将其传递给渲染进程。</li><li>缓存管理：根据缓存策略，将已加载的资源存储到本地，以便下次访问时直接使用。</li><li>协议处理：处理各种网络协议，如 HTTP、HTTPS、WebSocket 等。</li></ul></li><li><p><strong>插件进程</strong>：插件进程负责运行浏览器插件。它主要执行以下任务：</p><ul><li>插件加载：加载并初始化插件，如 Flash、PDF 阅读器等。</li><li>插件运行：运行插件代码，实现插件的功能。</li><li>插件沙箱：为插件提供一个隔离的运行环境，防止插件影响浏览器和网页的稳定性。</li></ul></li></ol><p>通过这种多进程架构，Chrome 浏览器可以在不同的进程中处理不同的任务，从而提高性能、稳定性和安全性。同时，当某个进程出现问题时，浏览器可以快速恢复，不会影响到其他进程和用户体验。或者某个页面崩溃只是自己的 对应的 tab 页进程崩溃并不会影响到其他页面，这种带来的缺点<strong>更高的资源占用</strong>。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</p><p><strong>注意即使是如今的多进程架构，偶尔还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况，原因是因为</strong></p><p>Chrome 的默认策略是，每个标签对应一个渲染进程。<strong>但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点（定义为根域名加上协议，该根域名下的所有子域名和不同的端口，通俗点一级域名二级域名这种）的话，那么新页面会复用父页面的渲染进程</strong>。官方把这个默认策略叫 process-per-site-instance。</p><p>这个过程：A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程</p><p><img src="'+s+'" alt="图 17"></p><p>那js 引擎线程在那个进程中，你要知道，当我们打开一个tab页面时就会开启一个新的进程，<strong>默认每个Tab对应对应一个遣染进程</strong>，<strong>这是为了防止一个页面卡死而造成所有页面无法响应，整个浏览器需要强制退出，每个遣染进程中又有很多的线程，例如其他线程</strong>：</p><ul><li><strong>GUI渲染线程</strong>:负责渲染页面和绘制图形，即将HTML、CSS和图片等资源解析为可视化的网页元素</li><li><strong>JS引擎线程</strong>:负责解析和执行JavaScript代码，使得网页具有交互性和动态效果。</li><li><strong>事件触发线程</strong>:负责监听用户操作或其他事件（如点击、滚动等），并触发相应的事件处理函数。</li><li><strong>定时触发器线程</strong>:负责执行定时器（如setTimeout和setInterval）中的回调函数，按照预定的时间间隔触发。</li><li><strong>异步HTTP请求线程</strong>:负责处理异步网络请求（如AJAX），从服务器端获取资源和信息，不会阻塞其他线程的执行。</li><li><strong>WebWorker</strong>:是一种在浏览器后台运行的JavaScript脚本，可以在不影响主线程的情况下执行耗时或复杂的任务。</li></ul><p>浏览器内核，通过下表也能发现<strong>浏览器内核等同渲染引擎（GUI渲染线程）</strong> 是浏览器的核心部分，它决定了浏览器如何解析和显示网页内容</p><table><thead><tr><th>浏览器内核</th><th>渲染引擎</th><th>JavaScript引擎</th><th>常见浏览器</th></tr></thead><tbody><tr><td>Blink</td><td>Blink</td><td>V8</td><td>Google Chrome, Opera, Microsoft Edge(Chromium版), Brave,Vivaldi等</td></tr><tr><td>WebKit</td><td>WebKit</td><td>JavaScriptCore</td><td>Safari, Google Chrome, Opera等</td></tr><tr><td>Gecko</td><td>Gecko</td><td>SpiderMonkey</td><td>Firefox,SeaMonkey等</td></tr><tr><td>Trident</td><td>MSHTML</td><td>Chakra</td><td>Internet Explorer, Maxthon等</td></tr><tr><td>EdgeHTML</td><td>EdgeHTML</td><td>Chakra</td><td>Microsoft Edge(旧版)</td></tr></tbody></table><p>说明：</p><ul><li><p><strong>Blink内核是由Google开发的浏览器渲染引擎</strong>，它是Webkit内核的一个分支，目前被Google Chrome、Opera等多个浏览器采用。V8引擎是Blink内核专门为JavaScript开发的引擎，具有快速、高效等特点。</p></li><li><p><strong>WebKit内核最早由苹果公司开发</strong>，包括Safari、Chrome、Opera等多个浏览器都采用了WebKit内核。JavaScriptCore引擎是WebKit内核专门为JavaScript开发的引擎。</p></li><li><p><strong>Gecko内核是由Mozilla基金会开发的浏览器渲染引擎</strong>，包括Firefox、SeaMonkey等多个浏览器都采用了Gecko内核。SpiderMonkey引擎是Gecko内核专门为JavaScript开发的引擎。</p></li><li><p><strong>Trident内核是由微软公司开发的浏览器渲染引擎</strong>，包括IE、Maxthon等多个浏览器都采用了Trident内核。Chakra引擎是Trident内核专门为JavaScript开发的引擎。</p></li><li><p><strong>EdgeHTML内核是由微软公司开发的浏览器渲染引擎</strong>，用于最初的Microsoft Edge浏览器。然而，自2020年1月起，Microsoft Edge已经转向使用Chromium内核。</p></li></ul><p><img src="'+l+'" alt="图 16"></p><p>一个浏览器至少实现三个常驻线程：<strong>javascript引擎线程</strong>，<strong>GUI渲染线程</strong>，<strong>浏览器事件触发线程</strong>。以Webkit内核为例，WebCore：负责HTML解析、布局、渲染等相关的操作；JavaScriptCore（JSCore）：解析和执行JavaScript代码；</p><h3 id="运行时runtime" tabindex="-1">运行时Runtime <a class="header-anchor" href="#运行时runtime" aria-label="Permalink to &quot;运行时Runtime&quot;">​</a></h3><p><strong>JavaScript宿主环境，也可以叫做 JavaScript运行时（Runtime）</strong>，宿主环境创建的一个作用域（scope）。在这个作用域内，JavaScript代码可以访问宿主环境提供的一系列特性。以浏览器为例，提供了一些额外的对象（API），<strong>这些对象可以让JavaScript代码与宿主环境进行交互</strong>。并且让这些API使得JavaScript代码能够访问和操作环境中的特定功能</p><p>例如操作DOM（浏览器中的文档对象模型）、发起网络请求（如Ajax请求）或内置API（如setTimeout、Promise等）以及宿主环境提供的特定API（如浏览器中的window、document对象）。</p><p>同样Node.js 作为运行时Runtime 也提供了fs、http模块等</p><p><strong>所以有了 Javascript 运行时（Runtime）就可以相同的JS引擎，在不同的环境下，便有不同的能力，js 常见提供 Javascript Runtime宿主, web 浏览器, node.js</strong>，下表展示两种不同的宿主环境（浏览器和Node.js），虽然他们的 js 引擎都是 V8 但是他们 容器不同，基于了他们额外的特性</p><table><thead><tr><th>宿主环境</th><th>JS引擎</th><th>运行时特性</th></tr></thead><tbody><tr><td>浏览器</td><td>Chrome V8引擎</td><td>DOM、window对象、用户事件、Timers等</td></tr><tr><td>Node.js</td><td>Chrome V8引擎</td><td>require对象、Buffer、Processes、fs等</td></tr></tbody></table><h3 id="webapi" tabindex="-1">webAPI <a class="header-anchor" href="#webapi" aria-label="Permalink to &quot;webAPI&quot;">​</a></h3><p><strong>webAPI 作为浏览器提供的一些额外的对象（API）</strong> 例如 setTimeout、setInterval和XHR在MDN上，这些功能被归类为&quot;Web API&quot;，它们是由WHATWG组织定义的。因此setTimeout和setInterval这类我们认为的 JavaScript的异步能力实际上是由所在容器（如浏览器）提供的，并不是JavaScript引擎本身的功能。</p><p>而JavaScript 引擎中的API 本身是由ECMAScript组织定义的。</p><p>&quot;Web API&quot;并不是JavaScript规范的一部分，而是浏览器容器额外提供的一些API方法。简单地说，<strong>&quot;Web API&quot;就是浏览器这个容器提供的JavaScript运行时</strong>。</p><p>从本质上讲，这些Web API是你无法直接访问的线程，但你可以调用它们。它们是浏览器并行启动的一部分。如果你是一个Node.js开发者，这些就相当于C++的一些API。</p><p>浏览器中 Web API的主要能力包括：</p><ol><li><p><strong>事件监听（Event Listeners）</strong>：允许JavaScript代码响应用户事件，如点击、滚动等。</p></li><li><p><strong>HTTP请求（HTTP request）</strong>：允许JavaScript代码通过XHR或Fetch API与服务器进行通信。</p></li><li><p><strong>定时功能（Timing functions）</strong>：如setTimeout和setInterval，允许JavaScript代码在特定时间后或周期性地执行某些操作。</p></li></ol><h2 id="浏览器输入网址后解析过程" tabindex="-1">浏览器输入网址后解析过程 <a class="header-anchor" href="#浏览器输入网址后解析过程" aria-label="Permalink to &quot;浏览器输入网址后解析过程&quot;">​</a></h2><p>之前我们是讨论是 V8 js引擎执行过程，现在将V8 放入到浏览器容器后，看整个浏览器执行过程 <img src="'+n+'" alt="图 1"></p><ol><li><p>首先，<strong>用户在浏览器搜索栏中输入服务器地址，与服务器建立连接</strong>，对浏览器输入的地址进行DNS解析，将域名解析成对应的IP地址；然后向这个IP地址发送http请求，服务器收到发送的http请求，处理并响应</p></li><li><p>处理 URL 请求响应回来的数据类型，根据响应头中的字段 <code>Content-Type</code> 它告诉浏览器服务器返回的响应体数据是什么类型,如果Content-type 字段的值不是 text/html。例如 application/octet-stream 浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，如果是 text/html 进入下一个流程，<strong>由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了</strong></p></li><li><p>默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程，服务器<strong>返回对应的静态资源取到 HTML 内容</strong>，浏览器获取到 HTML 内容后，就开始从上到下解析 HTML 的元素</p></li><li><p><code>&lt;head&gt;</code>元素内容会先被解析，此时浏览器还没开始渲染页面。当遇到<code>head</code> 标签内部一般会有</p><ul><li>页面元数据的<code>&lt;meta&gt;</code>元素</li><li>还有一些<code>&lt;link&gt;</code>元素涉及外部资源（如图片、CSS 样式等），此时浏览器会去获取这些外部 资源。</li><li><code>&lt;script&gt;</code>元素通过src属性指向外部资源。</li></ul></li><li><p>当浏览器解析<code>&lt;script&gt;</code>，会暂停解析并这个解析包裹 html css 解析。</p></li><li><p>当 JavaScript 脚本下载完成后，浏览器的控制权转交给 JavaScript 引擎。当脚本执行完成后，控制权会交回给渲染引擎，渲染引擎继续往下解析 HTML 页面。</p></li><li><p><code>&lt;body&gt;</code>元素内容开始被解析，浏览器开始渲染页面。</p></li></ol><h3 id="浏览器的页面渲染过程" tabindex="-1">浏览器的页面渲染过程 <a class="header-anchor" href="#浏览器的页面渲染过程" aria-label="Permalink to &quot;浏览器的页面渲染过程&quot;">​</a></h3><p>浏览器运行过程已经了解 下面进一步的页面渲染过程，也就是 渲染模块进程处理的过程 <img src="'+p+'" alt="图 6"></p><ol><li><p><strong>HTML Parser将HTML解析转换成DOM树</strong>；</p></li><li><p><strong>CSS Parser将样式表解析转换成CSS规则树</strong>；</p></li><li><p>转换完成的DOM树和CSS规则树Attachment（附加）在一起，并生成一个<strong>Render Tree（渲染树）</strong>；</p></li><li><p>需要注意的是，<strong>在生成Render Tree并不会立即进行绘制，中间还会有一个Layout（布局）操作，也就是布局引擎</strong>；</p></li><li><p>为什么需要布局引擎再对Render Tree进行操作？因为不同时候浏览器所处的状态是不一样的（比如浏览器宽度），<strong>Layout的作用就是确定元素具体的展示位置和展示效果；</strong></p></li><li><p><strong>有了最终的Render Tree，浏览器就进行Painting（绘制）</strong>，最后进行Display展示；</p></li><li><p>可以发现图中还有一个紫色的DOM三角，实际上这里是js对DOM的相关操作；</p></li><li><p>在HTML解析时，如果遇到JavaScript标签，就会停止解析HTML，而去加载和执行JavaScript代码；</p></li></ol><p>更加具体过程需要先了解下面几个知识点</p><h3 id="dom-树-处理-html-标记-构建-dom-树" tabindex="-1">DOM 树 -- 处理 HTML 标记，构建 DOM 树 <a class="header-anchor" href="#dom-树-处理-html-标记-构建-dom-树" aria-label="Permalink to &quot;DOM 树 -- 处理 HTML 标记，构建 DOM 树&quot;">​</a></h3><p>从发送HTTP请求到生成DOM树的过程，包括数据的传输、解析、词法分析和树结构生成。<strong>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构</strong></p><p>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。</p><p><img src="'+d+'" alt="图 13"></p><p><img src="'+c+'" alt="图 18"></p><ol><li><p>从服务器基于HTTP网路请求回来的数据：当我们在浏览器中输入一个网址并访问时，浏览器会向服务器发送一个HTTP请求，请求获取网页的数据。</p></li><li><p>16进制的文件流：服务器返回的数据是以16进制的文件流形式存在的，这是一种编码方式，用于在网络传输过程中保证数据的完整性。</p></li><li><p>浏览器把它解析为字符串（HTML字符串）：浏览器接收到16进制的文件流后，会将其解析成HTML字符串，也就是我们通常看到的HTML代码。</p></li><li><p>按照W3C规则识别成为一个个的节点「词法解析」：浏览器会根据W3C（万维网联盟）制定的规则，对HTML字符串进行词法解析，将其识别为一个个的节点，如标签、属性等。</p></li><li><p>生成树：经过词法解析后，浏览器会根据节点之间的关系生成一棵树结构，这棵树被称为DOM（文档对象模型）树。DOM树是浏览器对网页结构的一种表现形式，便于浏览器渲染页面和开发者操作页面元素。</p></li></ol><p><img src="'+g+'" alt="图 1"></p><h3 id="cssom树" tabindex="-1">CSSOM树 <a class="header-anchor" href="#cssom树" aria-label="Permalink to &quot;CSSOM树&quot;">​</a></h3><p>CSSOM 是一种浏览器内部的数据结构，用于表示 DOM 元素的样式信息。它包括了所有的 CSS 规则、样式属性和值，以及它们的优先级和继承关系等信息。CSSOM 可以通过 JavaScript 来访问和修改，从而实现对页面样式的动态控制。</p><ol><li>当处理HTML时，解析器可能会遇到包含，css 样式 此时需要将 CSS 转换为浏览器能够理解的结构，常见的 css 样式来源主要有三种 <ul><li>通过 link 引用的外部 CSS 文件</li><li><code>&lt;style&gt;</code>标记内的 CSS</li><li>元素的 style 属性内嵌的 CSS</li></ul></li></ol><p>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 <code>document.styleSheets</code></p><p><img src="'+b+'" alt="图 19"></p><ol start="2"><li>转换样式表中的属性值，使其标准化,CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。</li></ol><p><img src="'+h+'" alt="图 20"></p><ol start="3"><li>计算出 DOM 树中每个节点的具体样式,接着，根据CSS对象模型（CSSOM）规范，将这个CSS样式表解析成一个映射表（地图）。CSS 继承就是每个 DOM 节点都包含有父节点的样式计算时候要考虑进去</li></ol><ul><li><strong>如 body 节点的 font-size 属性是 20，那 body 节点下面的所有节点的 font-size 都等于 20。</strong></li></ul><p><img src="'+m+'" alt="图 21"></p><ul><li><strong>关于css 继承这里 可以参考， Chrome 的“开发者工具”，选择第一个 &#39;element&#39; 标签，再选择 &#39;style&#39; 子标签，你会看到如下界面</strong></li></ul><p><img src="'+S+'" alt="图 22"></p><p><strong>既然已经有了DOM树来表示HTML文档的结构，为什么不把CSS也放在DOM上，以便我们可以直接从元素上获取所有样式信息呢？</strong></p><p>很明显，如果把CSS信息一起建模在DOM结构上，就会违背&quot;单一职责原则&quot;。因为在网页中，HTML承担了语义职能，CSS承担了表现职能；同样地，在计算机中，DOM承担了语义职能，而CSSOM承担了表现职能。从下图可以看出，<strong>这里仅仅是对DOM节点的CSS进行了生成树，这时候并没有包含节点中的内容</strong>。</p><p><img src="'+f+'" alt="图 2"></p><h3 id="render-tree渲染树" tabindex="-1">Render-Tree渲染树 <a class="header-anchor" href="#render-tree渲染树" aria-label="Permalink to &quot;Render-Tree渲染树&quot;">​</a></h3><p>通过DOM树和CSSOM树来构建渲染树（Render Tree）</p><ol><li>当浏览器解析HTML文档时，会生成一个DOM树（Document Object Model Tree），表示页面的结构。同时，解析CSS样式表会生成一个CSSOM树（CSS Object Model Tree），表示页面的样式信息。</li><li>当DOM树和CSSOM树都构建完成后，浏览器会将它们结合起来，生成一个渲染树（Render Tree）。渲染树包含了页面中所有需要显示的元素及其样式信息。</li><li>在这个过程中，link元素（用于引入外部CSS样式表）不会阻塞DOM树的构建，但会阻塞渲染树的构建。这是因为在构建渲染树时，需要使用对应的CSSOM树来确定元素的样式。</li><li>需要注意的是，渲染树和DOM树并不是一一对应的关系。例如，如果一个元素的display属性设置为none，那么这个元素不会出现在渲染树中，因为它不需要显示在页面上。</li></ol><p><img src="'+u+'" alt="图 3"></p><h3 id="布局绘制" tabindex="-1">布局绘制 <a class="header-anchor" href="#布局绘制" aria-label="Permalink to &quot;布局绘制&quot;">​</a></h3><p>计算每个节点的几何形状和位置的步骤。渲染树是一个表示网页元素及其样式的树状结构，但它不包含元素的尺寸和位置信息。布局（Layout）是一个过程，它在渲染树上运行，以计算每个节点的宽度、高度和位置信息。这些信息将用于在屏幕上正确显示网页的各个元素。</p><p><img src="'+M+'" alt="图 4"></p><h3 id="将每个节点绘制-paint-到屏幕上" tabindex="-1">将每个节点绘制（Paint）到屏幕上 <a class="header-anchor" href="#将每个节点绘制-paint-到屏幕上" aria-label="Permalink to &quot;将每个节点绘制（Paint）到屏幕上&quot;">​</a></h3><p>：绘制阶段。在这个阶段，浏览器会根据之前计算好的布局信息（frame），将网页的各个元素绘制到屏幕上。绘制过程包括将元素的可见部分（如文本、颜色、边框、阴影等）转换为实际的像素点，以及处理替换元素（如图片）。这样，用户就能看到一个完整的网页界面。</p><p><img src="'+C+'" alt="图 5"></p><h3 id="回流和重绘" tabindex="-1">回流和重绘 <a class="header-anchor" href="#回流和重绘" aria-label="Permalink to &quot;回流和重绘&quot;">​</a></h3><p>回流（reflow）和重绘（repaint）是浏览器渲染过程中的两个重要概念。</p><p><strong>回流，也称为重排，是指浏览器重新计算元素的大小和位置</strong>。当页面布局发生变化时，浏览器需要重新计算元素的布局。回流的触发条件包括：DOM结构发生改变（如添加或移除节点）、修改元素的布局属性（如宽度、高度、内边距等）、窗口尺寸发生变化（如窗口缩放）等。</p><p><strong>重绘，是指浏览器重新渲染页面的内容</strong>。当元素的视觉样式发生变化时，浏览器需要重新绘制这些元素。重绘的触发条件包括：修改元素的背景色、文字颜色、边框颜色等样式属性。</p><p>需要注意的是，<strong>回流一定会引起重绘</strong>，因为元素的大小和位置发生变化后，浏览器需要重新绘制这些元素。但是，<strong>重绘不一定会引起回流</strong>。由于回流涉及到重新计算布局，因此它是一个性能消耗较大的过程。在进行页面优化时，应尽量减少回流和重绘的次数，以提高页面性能。</p><p><strong>因此要避免回流</strong>：</p><ol><li>一次性修改样式：在修改元素样式时，尽量一次性完成，可以通过设置cssText属性或者添加class的方式来实现。这样可以避免多次修改样式导致的性能损耗。</li></ol><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro"><code><span class="line"><span style="color:#E5C07B;">box</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">style</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">cssText</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;width: 200px; height: 200px; background-color: blue;&quot;</span><span style="color:#ABB2BF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="2"><li><p>避免频繁操作DOM：在对DOM元素进行操作时，尽量减少直接对页面上的元素进行操作。可以使用DocumentFragment或者父元素来完成需要的DOM操作，然后再一次性地将修改应用到页面上。这样可以减少页面的重绘和回流，提高性能。</p></li><li><p>使用position的absolute或者fixed：对于某些元素，可以使用position属性的absolute或者fixed值来进行定位。这样的元素在进行回流时，开销相对较小，不会对其他元素造成影响。这也有助于提高页面的性能。</p></li></ol><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://juejin.cn/post/6986265024255754248" target="_blank" rel="noreferrer">前端百题斩【029】——原来浏览器中存在五类进程</a></p><p><a href="https://blog.csdn.net/qq_26222859/article/details/77622222" target="_blank" rel="noreferrer">setTimeout解决GUI渲染线程阻塞问题</a></p><p><a href="https://stackoverflow.com/questions/59316975/the-javascript-v8-engine-and-web-apis" target="_blank" rel="noreferrer">Javascript v8引擎和Web API</a></p><p><a href="https://segmentfault.com/q/1010000002408941" target="_blank" rel="noreferrer">whatwg 是个什么组织？和 W3C 的关系是？</a></p><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=822#/detail/pc?id=7196" target="_blank" rel="noreferrer">01 | 重识 HTML，掌握页面基本结构和加载过程2021/04/09 王贝珊（被删）</a></p><p><a href="https://web.dev/howbrowserswork/#the-rendering-engines-threads" target="_blank" rel="noreferrer">浏览器是如何工作的</a></p><p><a href="https://www.cnblogs.com/MomentYY/p/15770904.html" target="_blank" rel="noreferrer">浏览器工作原理和JS引擎</a></p>',91),P=[_];function v(k,O,q,J,D,H){return e(),r("div",null,P)}const y=t(T,[["render",v]]);export{A as __pageData,y as default};
