---
description: 做一个todo express 实现的简单案例，使用express脚手架搭建项目，完成一个项目简单流程开发
tags:
  - 服务端
  - express
---

关于 `express generator`, 是一个官方提供的 Express 应用程序生成器，可以快速创建一个基本的 Express 应用程序骨架。它提供了一些预设的目录结构、文件和代码，可以帮助开发者快速搭建一个 Express 应用程序，并且可以选择使用不同的模板引擎。

使用 `Express Generator` 可以大大提高开发效率，避免了从头开始创建一个 Express 应用程序的繁琐过程。以下是使用 Express Generator 创建一个

## 使用

~~~shell
npx express-generator --view=ejs
~~~

## 生成的目录
使用 express 生成器生成的目录如下
~~~
├── bin
│   └── www
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
├── views
│   ├── error.ejs
│   ├── index.ejs
│   └── layout.ejs
├── app.js
├── package.json
└── README.md
~~~

- app.js：Express 应用程序的入口文件，用于配置和启动应用程序。
- bin/www：负责启动服务器的可执行文件。
- package.json：用于描述项目及其依赖项的元数据文件。
- public：存放静态文件的目录，包括图片、样式表和 JavaScript 文件。
    - images：存放图片文件的目录。
    - javascripts：存放浏览器端 JavaScript 文件的目录。
    - stylesheets：存放样式表文件的目录。
- routes：存放路由文件的目录，包括应用程序中的所有路由映射。
    - index.js：处理应用程序的根路径。
    - users.js：处理用户相关路径。
- views：存放 Express 视图文件的目录，用于呈现页面给用户。
    - error.ejs：展示错误信息的视图文件。
    - index.ejs：应用程序的主页视图文件。

### 生成的app.js 带来的知识点

通过生成的 app.js 文件来看带来的知识点

中间件上:

* http-errors 是一个用于创建 HTTP 错误的 Node.js 模块。使用 http-errors 可以方便地自定义错误消息和错误状态码。http-errors生成的error继承Error,所以可以通过error.message error.name error.stack分别获得错误的信息，名称，还有栈。同时它还多了一个error.status,该字段是http状态码

* cookie-parser 是一个用于解析 cookie 的 Node.js 模块。Express 应用程序中，可以使用 cookie-parser 模块来访问和解析 cookie。

* morgan 是一个 HTTP 请求日志中间件，用于记录应用程序的 HTTP 请求日志。在 Express 应用程序中，morgan 通常会添加到中间件堆栈中，以捕获和记录 HTTP 请求日志。中间件会将日志信息输出到控制台，也可以通过配置将日志输出到指定的文件中，通过查看文件或使用日志管理软件（如 Logstash 或 Splunk）来查看日志。您还可以使用 morgan 中间件提供的其他选项和方法来自定义日志的格式和输出方式

* express.json() 和 express.urlencoded 在之前我们提到处理时候使用的是 body-parser ，因为在以前的版本中，为了解析请求体数据，Express 需要依赖于第三方模块 body-parser。但在 Express 4.x 版本以后，中间件函数 `express.json()` 和 `express.urlencoded()` 被添加到了 Express 的核心中，因此不再需要安装和引入 body-parser 模块了,这会将解析后的**请求体数据**绑定到 req.body 对象中

:::tip 关于 express.urlencoded() 处理的数据格式
`express.urlencoded({ extended: false })` 方法解析的格式是 `x-www-form-urlencoded`，即 `application/x-www-form-urlencoded` 格式。这种格式是常用的 HTTP POST 请求数据提交方式，会将 HTTP 请求参数编码为键值对并以多个名称/值对以 `&` 符号分隔。例如，以下是一个请求数据字符串的示例：

```
name=John%20Doe&age=25
```

这个字符串对应着两个请求参数：`name` 和 `age`，它们分别对应着键值对 `name=John%20Doe` 和 `age=25`。在服务器端，`express.urlencoded({ extended: false })` 方法可以将这种格式的请求数据解析为一个 JavaScript 对象，以便我们在后续的处理中使用。


当将 extended 参数设置为 true 时，express.urlencoded() 方法可以解析更多的请求数据格式。具体来说，它可以处理具有嵌套结构的对象、数组、布尔值和其他复杂的数据类型。例如，如果我们使用以下方式提交的表单数据：
~~~html
<form action="/" method="POST">
  <input type="text" name="user[name]" value="John Doe">
  <input type="text" name="user[age]" value="30">
  <input type="checkbox" name="product[]" value="product1" checked>
  <input type="checkbox" name="product[]" value="product2">
  <input type="radio" name="gender" value="male">
  <input type="radio" name="gender" value="female" checked>
  <input type="submit">
</form>
~~~
则使用 extended: true 选项解析后得到的数据格式为：

{
  user: {
    name: 'John Doe',
    age: '30'
  },
  product: ['product1'],
  gender: 'female'
}
从上面的例子可以看出，extended: true 选项可以让我们更方便地处理复杂的表单数据。
:::


其他

* res.locals 在 Express 应用程序中，可以把一些变量存放在 res.locals 对象中，这些变量会被当做本地变量传递给渲染视图的模板引擎这也就是为什么没传递对象数据也能在页面被解析了

~~~js
var createError = require('http-errors') // 引入http-errors模块，用于创建http错误。
var express = require('express') // 引入express框架
var path = require('path') // 引入nodejs内置模块path，用于处理文件路径相关操作
var cookieParser = require('cookie-parser') // 引入cookie-parser模块，用于解析cookie
var logger = require('morgan') // 引入morgan模块，用于输出日志

var indexRouter = require('./routes/index') // 引入index.js文件
var usersRouter = require('./routes/users') // 引入users.js文件

var app = express() // 创建app应用

// view engine setup
app.set('views', path.join(__dirname, 'views')) // 设置views文件夹路径
app.set('view engine', 'ejs') // 设置使用ejs模板引擎

app.use(logger('dev')) // 使用morgan输出日志，dev模式输出颜色有区分
app.use(express.json()) // 解析json格式的请求体
app.use(express.urlencoded({ extended: false })) // 解析urlencoded格式的请求体，extended为false表示值可以是字符串或数组形式，true表示可以包含任何数据类型。
app.use(cookieParser()) // 解析cookie
app.use(express.static(path.join(__dirname, 'public'))) // 静态文件目录，用于存放css、js、images文件等

app.use('/', indexRouter) // 处理应用程序的根路径请求
app.use('/users', usersRouter) // 处理应用程序的/users路径请求

// 请求没有被前面的任何一个中间件或处理器匹配到，它就会被这段代码所捕获，然后进入错误处理流程。因此可以处理404错误。
app.use(function (req, res, next) {
	// 此时next 是由参数的因此 将会跳过所有的中间件和路由，直接进入错误处理流程。将进入错误中间
	next(createError(404)) // 捕获404错误并转发到错误处理程序
})

// 我是错误中间件
app.use(function (err, req, res, next) {
	// 在 Express 应用程序中，可以把一些变量存放在 res.locals 对象中，这些变量会被当做本地变量传递给渲染视图的模板引擎
	res.locals.message = err.message // 设置res.locals.message为错误信息
	res.locals.error = req.app.get('env') === 'development' ? err : {} // 设置res.locals.error为错误对象（仅在开发环境下）

	// render the error page
	res.status(err.status || 500) // 设置状态码为错误对象的状态码或500（服务器内部错误）
	res.render('error') // 渲染错误页
})

module.exports = app // 导出app对象

~~~

### Express Generator 生成bin/www 文件作用 ？？

需要后续了解


## 编写todo 案例

在开始案例之前需要了解一个库 lowdb ，在网站开发时候我们需要将数据进行一些存储可以选择使用关系型数据库（如 MySQL）或非关系型数据库（如 MongoDB）。但是，在一些小规模的项目中，使用一个完整的数据库可能过于笨重。

在这种情况下，可以使用 lowdb 是一个基于 JavaScript 的轻量级的本地 JSON 数据库，它的特点主要是方便易用和可嵌入性，让你可以更加自由的开发自己的业务。它使用了 lodash 的一些高级 API 来实现，所以它非常小而且快速；平均启动时间0.8 ms。它的 API 设计十分简单，最基本的增删查改等操作都是十分便捷，而且你可以把它应用到各种不同的项目中，比如构建网站、应用程序和桌面软件等。

此外，lowdb 的实现方式与传统数据库完全不同，它的数据存储方式为一个 JSON 文件，这样可以避免一些过多的配置和管理问题，不需要为了使用这个库而去管理一个成熟的数据库环境。使用 lowdb 可以让你更加专注于你的业务逻辑，而不是去研究复杂的数据库管理问题。总之，如果你想要一个非常简单易用的本地 JSON 数据库

为了使用cjs 版本 这里安装的是1.0版本
~~~shell
npm i lowdb@1.0.0
~~~

使用案例，每次启动
~~~js
//导入 lowdb
const low = require('lowdb')
const FileSync = require('lowdb/adapters/FileSync')
const adapter = new FileSync('db.json');
//获取 db 对象
const db = low(adapter);

//初始化数据
// db.defaults({ posts: [], user: {} }).write()

//写入数据
// db.get('posts').push({id: 2, title: '今天天气还不错~~'}).write();
// db.get('posts').unshift({id: 3, title: '今天天气还不错~~'}).write();
//获取单条数据
// let res = db.get('posts').find({id: 1}).value();
// console.log(res);

//获取数据
// console.log(db.get('posts').value());

//删除数据
// let res = db.get('posts').remove({id: 2}).write();
// console.log(res);

//更新数据
// db.get('posts').find({id: 1}).assign({title: '今天下雨啦!!!'}).write()
~~~

### 上传中间件
上传中间件选择是 [multer](https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md) ,在上传时候一般使用格式是`multipart/form-data`,为了可以处理此时就需要 multer , 可以通过 `req.body` 获取普通表单字段，上传文件需要根据对应 `req.file` 进行获取

基本使用上有两种模式 暂时保存在内存中 和 直接保存在本地磁盘里，具体使用可以参考文档，但要注意的是获取的文件名称是中文可能会乱码，需要使用 	`Buffer.from(file.originalname, 'latin1').toString('utf8')` 去转码

在 案例中使用的代码位置是 routes/todo.js 中，可以看到在导入 `require('multer')` 后去定义了使用了  `multer.diskStorage` 将上传文件保存在了磁盘中，提供了 `destination` 和  `filename` 通过提供的回调函数进行格式上的修改，默认上multer 特殊性质导致名字生成 不会为你添加任何扩展名，所以会在 `filename` 去定义我们实际保存的名字，multer 也提供了 `fileFilter` 这个字段可以帮助进行一些类型判断，
将错误抛出异常
~~~js
var express = require('express')
var router = express.Router()
const path = require('path')
const shortid = require('shortid')

// 确保你总是处理了用户的文件上传。 永远不要将 multer 作为全局中间件使用，
// 因为恶意用户可以上传文件到一个你没有预料到的路由，应该只在你需要处理上传文件的路由上使用。
const multer = require('multer')

// 保存在磁盘上
const storage = multer.diskStorage({
	// 设置保存位置路径
	// destination: '/upload',
	destination(req, file, cb) {
		cb(null, './uploads')
	},
	// 设置项目名称
	filename(req, file, cb) {
		// 由于multer 特殊性质导致名字生成 不会为你添加任何扩展名，会自动把文件的后缀名删除并添加一个随机的扩展名，这是为了防止文件名重复和安全问题
		// 我要自动拼接文件名 时间戳 + 文件名
		const prefix = Date.now()
		// 参考 https://github.com/expressjs/multer/issues/1104 解决文件上传乱码问题
		const fileName = path.basename(
			Buffer.from(file.originalname, 'latin1').toString('utf8')
		)
		cb(null, `${prefix}-${fileName}`)

		// const extension = path.extname(originalname)
		// const basename = path.basename(originalname, extension) // 不包括扩展名只包含文件名
		// const encodedName = encodeURIComponent(basename)
		// const newFilename = `${encodedName}-${Date.now()}${extension}`
	},
})

const upload = multer({
	storage,
	limits: { fileSize: 2 * 1024 * 1024 },
	fileFilter(req, file, cb) {
		// 过滤文件类型
		const fileType = file.mimetype.toLowerCase()

		if (
			fileType === 'image/png' ||
			fileType === 'image/jpg' ||
			fileType === 'image/jpeg' ||
			fileType === 'image/webp'
		) {
			cb(null, true)
		} else {
			cb(new Error({ code: 'FILE_TYPE' }), false)
		}
	},
})

// 新增： 增加个人任务 在html页面时候 图片对应字段为file 作为前端传过来的key
router.post(
	'/add',
	upload.single('file'),
	(req, res) => {
		// req.file 是 `avatar` 文件的信息
		// req.body 将具有文本域数据，如果存在的话

		// 逻辑将数据保存到dblow 上， 可以参考https://github.com/hua1995116/webchat/blob/d3f37273bff43b297148846c5122384d618149fc/router/files.js#L41
		console.log(req.file, 111111111)

		// 只要是上传不符合要求的文件，cb(123, false) 此时就没有req.file
		// if (!req.file) {
		// 	res.json({ msg: '文件错误' })
		// 	return
		// }
		let imgPath = ''
		let id = shortid.generate()

		if (req.file) {
			// 保存图片路径
			imgPath = path.normalize(req.file.path)
		}
		req.db
			.get('todos')
			.push({ id, ...req.body, imgPath })
			.write()
		res.json({ msg: '新增成功', code: 200 })
	},
	(err, req, res, next) => {
		// 为精确的错误处理，你可以使用 instance 来确定 MulterError 是不是你想要的错误类型。
		if (err.code === 'LIMIT_FILE_SIZE') {
			// limits 错误会进入  multer.MulterError 收集
			res.json({ msg: '文件过大', code: 500 })
		} else if (err.code === 'FILE_TYPE') {
			res.json({ msg: '文件类型不符合要求', code: 500 })
		}
		next(err)
	}
)


~~~

## 项目地址

![](/images/express_增删改查1.png)

![](/images/express_增删改查2.png)

