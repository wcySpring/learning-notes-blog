---
description:  Express.js 的中间件是一种函数，它可以在请求和响应之间进行处理
tags:
  - 服务端
  - express
---

Express 中间件是**一种函数**，它可以在**请求和响应之间进行处理**。它可以访问请求对象（req）、响应对象（res）和应用程序的下一个中间件函数（next）。中间件可以用来执行各种任务，例如验证请求、处理错误、记录请求等。做为回调函数接受三个参数
* 请求对象（request对象）
* 响应对象（response对象）
* next函数（在express中定义的用于执行下一个中间件的函数）
![](/images/express_middle.png)

中间件作用使用函数封装公共操作，简化代码

* 执行任何代码。
* 对请求和响应对象进行更改。
* 结束请求/响应循环。
* 调用堆栈中的下一个中间件。
![](/images/express_next流程.png)


## 中间的类型

1. 应用层中间件： 应用层中间件是通过 app.use() 和app.METHOD()绑定到应用程序对象的实例，  函数注册的中间件。它们在整个应用程序中都可以使用，并且可以处理所有进入应用程序的请求。应用层中间件可以用于处理身份验证、日志记录、请求解析和其他通用任务。

2. 路由器层中间件： 路由器层中间件是通过 express.Router() 函数创建的路由器对象上注册的中间件。它们只能处理与路由器对象关联的特定路由。路由器层中间件可以用于处理特定路由的身份验证、请求解析和其他任务。

3. 错误处理中间件： 回调函数参数有个四个以将函数标识为错误处理中间件函数，它们专门用于处理应用程序中的错误。当应用程序中发生错误时，错误处理中间件会捕获错误并向客户端发送适当的错误响应。

4. 内置中间件： 内置中间件是 Express 框架自带的中间件，可以通过 app.use() 函数直接使用。 V4.x 起只有 express.static()。

5. 第三方中间件： 第三方中间件是由第三方开发人员创建的中间件，可以通过 npm 包管理器安装并使用。第三方中间件可以用于处理身份验证、日志记录、请求解析和其他任务。常见的第三方中间件包括 body-parser、cookie-parser、passport 等 更多的中间件参考https://github.com/Raynos/http-framework#modules 或者 https://expressjs.com/en/resources/middleware.html。

| 中间件模块 | 描述 | 替代内置函数（Express 3） |
| --- | --- | --- |
| body-parser | 解析HTTP请求体。参见：body、co-body和raw-body。 | express.bodyParser |
| compression | 压缩HTTP响应。 | express.compress |
| connect-rid | 生成唯一的请求ID。 | NA |
| cookie-parser | 解析cookie头并填充req.cookies。参见cookies和keygrip。 | express.cookieParser |
| cookie-session | 建立基于cookie的会话。 | express.cookieSession |
| cors | 使用各种选项启用跨源资源共享（CORS）。 | NA |
| errorhandler | 开发时的错误处理/调试。 | express.errorHandler |
| method-override | 使用标头覆盖HTTP方法。 | express.methodOverride |
| morgan | HTTP请求日志记录器。 | express.logger |
| multer | 处理多部分表单数据。 | express.bodyParser |
| response-time | 记录HTTP响应时间。 | express.responseTime |
| serve-favicon | 提供一个网站图标。 | express.favicon |
| serve-index | 为给定路径提供目录列表。 | express.directory |
| serve-static | 提供静态文件。 | express.static |
| session | 建立基于服务器的会话（仅限开发）。 | express.session |
| timeout | 为HTTP请求处理设置超时时间。 | express.timeout |
| vhost | 创建虚拟域。 | express.vhost |

| 额外的中间件模块 | 描述 |
| --- | --- |
| cls-rtracer | 基于CLS的请求ID生成中间件。用于将请求ID添加到日志中。 |
| connect-image-optimus | 优化图片服务。如果可能的话，将图片转换为.webp或.jxr格式。 |
| express-debug | 开发工具，向模板变量（locals）、当前会话等添加信息。 |
| express-partial-response | 基于字段查询字符串过滤JSON响应的部分内容；使用Google API的Partial Response。 |
| express-simple-cdn | 使用CDN提供静态资源，支持多个主机。 |
| express-slash | 处理有和没有尾部斜杠的路由。 |
| express-stormpath | 用户存储、认证、授权、SSO和数据安全。 |
| express-uncapitalize | 将包含大写字母的HTTP请求重定向到规范小写形式。 |
| helmet | 通过设置各种HTTP标头来加强应用程序的安全性。 |
| join-io | 实时合并文件以减少请求次数。 |
| passport | 使用“策略”进行身份验证，如OAuth、OpenID等。有关更多信息，请参见http://passportjs.org/。 |
| static-expiry | 为静态资源指纹URL或缓存头。 |
| view-helpers | 视图的常用辅助方法。 |
| sriracha-admin | 动态生成Mongoose的管理站点。 |


## app.use
app.use()是Express.js中的中间件函数，用于将中间件函数绑定到应用程序中的各个路由上，app.use()函数接受多个中间件函数作为参数，多个中间件函数按照调用顺序依次执行。

app.use()函数接受两种类型的参数：中间件函数或路由路径。当传递中间件函数时，该函数将应用于所有请求。例如：

```js
app.use((req, res, next) => {
  console.log('Logging...');
  next();
});
```

传递路由路径作为第一个参数时，中间件函数将应用于匹配该路径的请求。例如：

```js
app.use('/api', (req, res, next) => {
  console.log('API Logging...');
  next();
});
```

以上代码将仅在请求路径以“/api”开头时记录日志信息。可以将多个中间件函数和路由路径组合使用：

```js
app.use('/api', (req, res, next) => {
  console.log('API Logging...');
  next();
}, (req, res, next) => {
  console.log('API Authentication...');
  next();
});
```

其中，第一个中间件函数仅应用于以“/api”开头的请求，第二个中间件函数应用于满足第一个中间件函数的请求。

## 案例app.use 和 app.Method 中间件

使用 app.use 和 app.Method 中间件
~~~js
const express = require('express')
const fs = require('fs')

const app = express()

// 定义一个记录ip的中间件
function logIp(req, res, next) {
	console.log(req.ip)
	fs.appendFileSync('ip.txt', req.ip + '\n')
	// 调用next 才能执行下一个中间件
	next()
}

// 记录一个请求时间的中间件
function logTime(req, res, next) {
	console.log(new Date())
	next()
}

// 定义一个请求方法中间件
function logMethod(req, res, next) {
	console.log(req.method)
	next()
}

// 应用中间件 全局性质的
app.use(logIp, logTime)

// 应用中间件 路由局部性质的
app.get('/', logMethod, (req, res) => {
	res.send('hello world')
})

// 这个就只有 logTime logIp 中间件 生效 logMethod不生效
app.get('/user', (req, res) => {
	res.send('user page')
})

// 启动服务
app.listen(3000, () => {
	console.log('server is running at port 3000')
})

~~~


也可以app.Method 数组
~~~js
var cb0 = function (req, res, next) {
  console.log('CB0');
  next();
}

var cb1 = function (req, res, next) {
  console.log('CB1');
  next();
}

var cb2 = function (req, res) {
  res.send('Hello from C!');
}

app.get('/example/c', [cb0, cb1, cb2]);

~~~


## 错误处理中间件案例
错误处理中间件函数的定义方式与其他中间件函数基本相同，差别在于错误处理函数有四个自变量而不是三个，专门具有特征符 (err, req, res, next)
~~~js
app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
~~~

* 使用next 传递报错信息

~~~js
const express = require('express')
const fs = require('fs')

const app = express()

app.use(function (req, res, next) {
	// 假设用户已经登录，将用户信息存储在 req.user 中
	req.user = {
		id: 123,
		name: 'John Doe',
		email: 'john@example.com',
		hasPaid: false,
	}
	next()
})

// 错误处理中间件 中间件执行顺序问题这里还不能执行到
// app.use(function (err, req, res, next) {
// 	console.error(err)
// 	res.status('404').send('Something broke!')
// })

app.get(
	'/',
	function checkIfPaidSubscriber(req, res, next) {
		if (!req.user.hasPaid) {
			// continue handling this request
			next('错误信息')
		} else {
			next()
		}
	},
	function getPaidContent(req, res, next) {
		res.json({ name: '123' })
	}
	// 也可以自己内部错误中间件，这样优先自己的不会在走全局的出来
	// function getPaidContent(error, req, res, next) {
	// 	console.log(456)
	// 	res.json({ name: '123' })
	// }
)

// 错误处理中间件 错误中间放到最后执行到了
app.use(function (err, req, res, next) {
	console.error(err) // 错误信息
	res.status('500').send('Something broke!')
})

// 启动服务
app.listen(3000, () => {
	console.log('server is running at port 3000')
})


~~~

## 内置中间 express.static
自从 Express 版本 4.x 开始，Express 不再依赖于 Connect 框架。除了 express.static 中间件函数之外，以前 Express 内置的所有中间件函数现在都以单独的模块形式提供。用户可以查看中间件函数列表来获取更多信息。这意味着用户需要手动安装和导入所需的中间件模块，而不是像以前那样直接使用 Express 内置的中间件函数。

~~~js
express.static(root, [options])

~~~

是在使用 Express 框架中，将静态文件托管到 public 目录下，并将其映射到 /static 路径下。这样相当于我们隐藏了静态文件实际访问路径，我们通过'/static' 重新映射
~~~js
app.use('/static', express.static(__dirname + '/public'));

~~~

| 属性 | 描述 | 类型 | 缺省值 |
| --- | --- | --- | --- |
| `dotfiles` | 是否对外输出文件名以点（.）开头的文件。有效值包括“allow”、“deny”和“ignore” | 字符串 | “ignore” |
| `etag` | 启用或禁用 etag 生成 | 布尔 | `true` |
| `extensions` | 用于设置后备文件扩展名。 | 数组 | `[]` |
| `index` | 发送目录索引文件。设置为`false`可禁用建立目录索引。 | 混合 | “index.html” |
| `lastModified` | 将`Last-Modified`的头设置为操作系统上该文件的上次修改日期。有效值包括`true`或`false`。 | 布尔 | `true` |
| `maxAge` | 设置 Cache-Control 头的 max-age 属性（以毫秒或者[ms 格式](https://www.npmjs.org/package/ms)中的字符串为单位） | 数字 | 0 |
| `redirect` | 当路径名是目录时重定向到结尾的“/”。 | 布尔 | `true` |
| `setHeaders` | 用于设置随文件一起提供的 HTTP 头的函数。 | 函数 |   |


1. dotfiles：该配置项用于控制是否允许输出以点（.）开头的文件名。在 Unix 系统中，以点开头的文件通常被视为隐藏文件，因此默认情况下，serve-static 不会输出这些文件。如果需要输出这些文件，可以将该配置项设置为 allow。如果需要完全禁止输出这些文件，可以将该配置项设置为 deny。如果不需要特殊处理这些文件，可以将该配置项设置为 ignore。

2. etag：该配置项用于控制是否启用 etag 生成。etag 是一种用于缓存控制的机制，可以根据文件内容生成一个唯一的标识符，用于判断文件是否发生了变化。如果启用 etag 生成，serve-static 会在响应头中添加 ETag 字段。如果禁用 etag 生成，serve-static 不会添加 ETag 字段。

::: tip
etag 是 HTTP 协议中的一个头部字段，全称是 Entity Tag。它是由服务器生成的一个唯一标识符，用于标识一个特定的资源（比如一个文件）。当客户端请求该资源时，服务器会将 etag 值发送给客户端。客户端可以在后续的请求中将该值发送给服务器，以便服务器判断该资源是否已经被修改过。如果 etag 值相同，说明资源没有被修改过，服务器可以返回 304 Not Modified 响应，告诉客户端可以使用缓存的版本。

在配置中，etag 参数控制是否启用 etag 生成。默认情况下，etag 参数为 true，表示启用 etag 生成。如果设置为 false，则服务器不会生成 etag 值。如果你的服务器上的资源不会经常修改，可以考虑启用 etag 生成，以便客户端可以使用缓存的版本，减少网络流量和服务器负载。但是如果你的服务器上的资源经常修改，那么 etag 生成会增加服务器负载，不建议启用。
:::

3. extensions：该配置项用于设置后备文件扩展名。后备文件是指当请求的文件不存在时，serve-static 会尝试查找具有相同文件名但不同扩展名的文件。例如，如果请求的文件是 index.html，但是该文件不存在，serve-static 会尝试查找 index.htm 文件。如果该文件存在，则返回该文件。如果该文件不存在，则继续查找其他后备文件。该配置项的值为一个数组，数组中的每个元素都是一个后备文件扩展名，例如 ['.html', '.htm']。

4. index：该配置项用于控制是否发送目录索引文件。如果设置为 false，则禁用建立目录索引。如果设置为字符串，则发送该字符串所指定的文件名作为目录索引文件。例如，如果设置为 'index.htm'，则 serve-static 会在请求的目录中查找 index.htm 文件，并将其作为目录索引文件返回。

::: tip
假设你的服务器上有一个目录 /var/www/html，里面有以下文件：

index.html
about.html
contact.html
如果你在配置中设置了 index 参数为 true（默认值），那么当客户端请求 http://yourdomain.com/ 时，服务器会发送 /var/www/html/index.html 文件作为响应。如果客户端请求 http://yourdomain.com/about/，服务器会发送 /var/www/html/about/index.html 文件作为响应（如果该文件存在），否则发送 /var/www/html/about.html 文件作为响应。

如果你将 index 参数设置为 false，那么当客户端请求 http://yourdomain.com/ 或 http://yourdomain.com/about/ 时，服务器会发送一个 403 Forbidden 错误。

如果你将 index 参数设置为 'home.html'，那么当客户端请求 http://yourdomain.com/ 时，服务器会发送 /var/www/html/home.html 文件作为响应。如果客户端请求 http://yourdomain.com/about/，服务器会发送 /var/www/html/about/home.html 文件作为响应（如果该文件存在），否则发送 /var/www/html/about.html 文件作为响应。
:::

5. lastModified：该配置项用于控制是否将 Last-Modified 的头设置为操作系统上该文件的上次修改日期。如果启用该配置项，serve-static 会在响应头中添加 Last-Modified 字段。如果禁用该配置项，则不会添加 Last-Modified 字段。

6. maxAge：该配置项用于设置 Cache-Control 头的 max-age 属性，以毫秒或者 ms 格式中的字符串为单位。max-age 表示缓存时间，即在该时间内，浏览器可以直接从缓存中获取文件，而不需要重新请求服务器。例如，设置为 '1d' 表示缓存时间为一天。

7. redirect：该配置项用于控制当路径名是目录时，是否重定向到结尾的“/”。如果启用该配置项，serve-static 会将请求重定向到以“/”结尾的路径。如果禁用该配置项，则不会进行重定向。

8. setHeaders：该配置项用于设置随文件一起提供的 HTTP 头的函数。该函数接收两个参数：res（响应对象）和 path（文件路径）。在该函数中，可以使用 res.setHeader() 方法设置 HTTP 头。例如，可以使用该函数设置 Content-Type 头。

### 案例
~~~
.
|-- app.js
|-- ip.txt
|-- package-lock.json
|-- package.json
`-- public
    |-- css
    |   `-- index.css
    `-- index.html
~~~
默认静态资源 索引是index.html。因此可以直接通过 http://localhost:3000/ 访问程序index.html 页面
~~~js
const express = require('express')
const fs = require('fs')

const app = express()

// 静态资源托管
app.use(express.static('./public'))

// 启动服务
app.listen(3000, () => {
	console.log('server is running at port 3000')
})

~~~


:::tip 关于顺序注意事项:
1. index.html 文件为默认打开的资源
2. 如果静态资源与路由规则同时匹配，谁先匹配谁就响应
3. 路由响应动态资源，静态资源中间件响应静态资源
:::
~~~js
//引入express框架
const express = require('express')
//创建服务对象
const app = express()
//静态资源中间件的设置，将当前文件夹下的public目录作为网站的根目录
app.use(express.static('./public')) //当然这个目录中都是一些静态资源
//如果访问的内容经常变化，还是需要设置路由
//但是，在这里有一个问题，如果public目录下有index.html文件，单独也有index.html的路由，
//则谁书写在前，优先执行谁
app.get('/index.html', (request, response) => {
	respsonse.send('首页')
})
//监听端口
app.listen(3000, () => {
	console.log('3000 端口启动....')
})

~~~

## 第三方中间件

使用 获取请求体数据 body-parser

第一步：安装
~~~shell
npm i body-parser
~~~

~~~js
const express = require('express')
const bodyParser = require('body-parser')

const app = express()

// 处理json格式的请求体数据  挂在全局使用
// app.use(bodyParser.json())
// 处理post forrmat格式的请求体数据 挂在全局使用
// app.use(bodyParser.urlencoded({ extended: false }))

// 处理post forrmat格式的请求体数据
const urlencodedParser = bodyParser.urlencoded({ extended: false })

// 配置路由
app.get('/', (req, res) => {
	res.sendFile(__dirname + 'public/index.html')
})

// 处理post请求
app.post('/login', urlencodedParser, (req, res) => {
	console.log(req.body) // 使用了body-parser中间件，可以解析请求体数据 例如{ userName: 'qqq', password: '456' }
	res.send('post login')
})

app.post('/login1', (req, res) => {
	console.log(req.body) // undefined 不能解析请求体数据
	res.send('post login')
})

app.post('/login2', bodyParser.json(), (req, res) => {
	console.log(req.body) // 解析json  例如{ userName: 'qqq', password: '456' }
	res.send('post login')
})

// 启动服务
app.listen(3000, () => {
	console.log('server is running at port 3000')
})

~~~