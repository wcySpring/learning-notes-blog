---
description: 依赖注入
---

先从概念的大维度来看 `IOC（控制反转）Inversion of Control）` 和 `DI（依赖注入）（Dependency Injection）`

IOC（控制反转）Inversion of Control） 是一种**设计原则**，用于减少代码之间的耦合。传统的编程方式中，程序直接控制其所依赖的对象的创建和管理，而使用 IOC 时，对象的创建和管理权被反转给了容器或框架。程序不再主动创建对象，而是被动接收由容器或框架注入的对象

DI（依赖注入）（Dependency Injection）是实现 IOC 的一种手段。通过 DI，我们可以将类的依赖项（即它所需要的对象）注入到类中，而不是在类内部创建这些依赖项。这样可以使得类更加易于测试、维护和扩展。

依赖注入（DI），是一种设计模式,将依赖通过 注入 的方式提供给需要的类。一般来讲，主要有三种方式来注入类：**通过构造函数**、**设值方法注入**和**接口注入** （不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。）。 有的也可以通过装饰器注入。

构造函数注入和设值方法注入是最常见的两种方式，而注解注入则通常与依赖注入框架结合使用，以简化依赖关系的声明和管理。选择哪种方式取决于具体的应用需求和设计目标。

往往依赖注入和控制反转搭配在一起，IoC 容器（又叫作 DI 容器），是用于实现自动依赖注入的框架。它的作用是管理对象的创建及其生命周期，并提供向类注入依赖项的具体实现，这样做是为了我们不必手动创建和管理对象。

## 在 NestJS 角度来看IOC

IoC 容器可以看作是一个帮你管理对象（比如服务、控制器等）的“工厂”。在传统的编程中，你需要手动创建对象，并在代码的不同部分传递这些对象。但在有了 IoC 容器后，这些对象的创建和传递就由容器自动完成了。

在 NestJS 中，这个“工厂”就是由框架本身管理的。NestJS 会自动帮你创建你需要的对象，并在需要的地方自动提供给你。你不需要手动去创建这些对象，也不需要担心它们什么时候销毁，NestJS 都会帮你处理好。

从下面例子来看 IoC 容器的作用相当于从外部注入依赖，而不是在类内部创建依赖类对象。

~~~ts
const userService = new UserService();
~~~

你得手动创建 `UserService` 的实例，然后在应用程序的其他部分传递这个实例。这样做麻烦且容易出错。

但在 `NestJS` 中，你只需要告诉 `NestJS` 这个 `UserService` 需要被使用：

~~~ts
@Injectable()
export class UserService {
  // 用户相关的逻辑
}
~~~

接着，当你在另一个类（比如 UserController）中需要用到 UserService 时，只需要这样做：

~~~ts
@Controller()
export class UserController {
  constructor(private readonly userService: UserService) {}

  // 使用 this.userService 访问 UserService 的功能
}
~~~

这里的 `UserService` 会自动由 NestJS 创建，并且在需要的时候传递给 `UserController`。你不需要自己去管理这个过程。NestJS 的 IoC 容器就像一个自动化助手

- **自动创建对象** ：NestJS 会看到你在 UserController 中需要 UserService，然后它会自动创建一个 UserService 的实例。

- **自动注入依赖** ：NestJS 会把创建好的 UserService 实例自动传递给 UserController，你可以直接使用。

- **管理对象的生命周期** ：NestJS 会决定什么时候创建 UserService，什么时候销毁它，你不需要关心这些细节。
 
### NestJs 中使用  `@Injectable()` 和 `@Inject()` 

在这之前要搞懂 两个单词的中文意思 `@Injectable()` 和 `@Inject()` 

- `@Injectable()` ：表示“这个类是可被注入的”。被标记为 `@Injectable()` 的类可以作为其他类的依赖被注入。
  
- `@Inject()`：表示“注入某个特定的依赖”。它允许你手动指定要注入的依赖。

到目前这里还是不太清除，举一个例子来更清楚这两个属性

首先注入 `@Injectable()` 来注册一个可被注入的类

~~~ts
import { Injectable } from "@nestjs/common";

@Injectable()
export class UserModule {
  name: string = "w";
  age: number = 12;

  get info() {
    return `${this.name}_${this.age}`;
  }
}
~~~

这里需要 `providers` 去告诉 NestJS 这个服务可以用于依赖注入。也就不仅需要 `Injectable` 还需要 `providers` 去注册这个服务
~~~ts
import { UserController } from "src/injectable/user.controller";
import { AppController } from "./app.controller";

import { Module } from "@nestjs/common";
import { UserModule } from "src/injectable/user.module";
import { UserController1 } from "src/injectable/user.controller1";

// nest 创建一个新的模块。这个模块是一个类，用 @Module 装饰器装饰
/**
 * @Module是一个装饰器，用于定义模块
 * 模块是组织代码的基本单元，它将相关的组件(控制器、服务器、提供者)组合在一起
 * Nest的模块系统是受Angular启动
 */
@Module({
  controllers: [AppController, UserController, UserController1],
  providers: [UserModule, { provide: "UserModule1", useClass: UserModule }],
})
export class AppModule {}
~~~

现在来看  UserController 和  UserController1 的使用

`UserController` 中注入 `UserModule` 因为 Injectable 进行了注入，用了providers 注册了 UserModule ，现在只要在装饰器里面参数 ts 声明的类型进行形成了匹配，Nestjs 就会自动注入 UserModule 到 UserController 中


~~~ts
import { Controller, Get } from "@nestjs/common";
import { UserModule } from "./user.module";

@Controller("user")
export class UserController {
  // 注入到 User
  constructor(private readonly user: UserModule) {}

  @Get("/info")
  getInfo() {
    return this.user.info;
  }
}
~~~


在 `UserController1` 中，使用 `@Inject` 装饰器手动指定要注入的依赖项。这种方式允许更灵活的依赖项注入，尤其是在依赖项通过字符串标识（通常在提供者模式下）时。@Inject 装饰器会告诉 NestJS 需要从依赖注入容器中获取对应的依赖，并将其注入到指定的属性中。 可以**理解为指定映射注入**

~~~ts
import { Controller, Get, Inject } from "@nestjs/common";

@Controller("user1")
export class UserController1 {
  // 注入到 User

  @Inject("UserModule1")
  // 也可以这样 本质其实  providers: [UserModule] = 》providers: [{ provide: UserModule, useClass: UserModule }]
	// @Injectable(UserModule)
  private readonly user;
	// 也可以这样
  // constructor(@Inject("UserModule1") private readonly user) {}

  @Get("/info")
  getInfo() {
    return this.user.info;
  }
}
~~~

两者对比来看 在 UserController 的构造器里参数里声明了 UserModule 的依赖，就会自动注入，但有时如果在构造函数传参去定义的一些接口或者 父类 或者起了别名 这种形式 就需要使用 `@Inject` 去指定要注入的依赖项。 在是否需要使用 `@Inject` 取决于如果你的类没有扩展另一个类，那么你应该始终更喜欢使用基于构造函数的注入。构造函数明确概述了所需的依赖，并提供比使用 `@Inject` 注释的类属性更好的可见性。


### NestJs 中使用  `providers` 
