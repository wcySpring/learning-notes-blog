---
description: 依赖注入
---

先从概念的大维度来看 `IOC（控制反转）Inversion of Control）` 和 `DI（依赖注入）（Dependency Injection）`

IOC（控制反转）Inversion of Control） 是一种**设计原则**，用于减少代码之间的耦合。传统的编程方式中，程序直接控制其所依赖的对象的创建和管理，而使用 IOC 时，对象的创建和管理权被反转给了容器或框架。程序不再主动创建对象，而是被动接收由容器或框架注入的对象

DI（依赖注入）（Dependency Injection）是实现 IOC 的一种手段。通过 DI，我们可以将类的依赖项（即它所需要的对象）注入到类中，而不是在类内部创建这些依赖项。这样可以使得类更加易于测试、维护和扩展。

依赖注入（DI），是一种设计模式,将依赖通过 注入 的方式提供给需要的类。一般来讲，主要有三种方式来注入类：**通过构造函数**、**设值方法注入**和**接口注入** （不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。）。 有的也可以通过装饰器注入。

构造函数注入和设值方法注入是最常见的两种方式，而注解注入则通常与依赖注入框架结合使用，以简化依赖关系的声明和管理。选择哪种方式取决于具体的应用需求和设计目标。

往往依赖注入和控制反转搭配在一起，IoC 容器（又叫作 DI 容器），是用于实现自动依赖注入的框架。它的作用是管理对象的创建及其生命周期，并提供向类注入依赖项的具体实现，这样做是为了我们不必手动创建和管理对象。

## 在 NestJS 角度来看IOC

IoC 容器可以看作是一个帮你管理对象（比如服务、控制器等）的“工厂”。在传统的编程中，你需要手动创建对象，并在代码的不同部分传递这些对象。但在有了 IoC 容器后，这些对象的创建和传递就由容器自动完成了。

在 NestJS 中，这个“工厂”就是由框架本身管理的。NestJS 会自动帮你创建你需要的对象，并在需要的地方自动提供给你。你不需要手动去创建这些对象，也不需要担心它们什么时候销毁，NestJS 都会帮你处理好。

从下面例子来看 IoC 容器的作用相当于从外部注入依赖，而不是在类内部创建依赖类对象。

~~~ts
const userService = new UserService();
~~~

你得手动创建 `UserService` 的实例，然后在应用程序的其他部分传递这个实例。这样做麻烦且容易出错。

但在 `NestJS` 中，你只需要告诉 `NestJS` 这个 `UserService` 需要被使用：

~~~ts
@Injectable()
export class UserService {
  // 用户相关的逻辑
}
~~~

接着，当你在另一个类（比如 UserController）中需要用到 UserService 时，只需要这样做：

~~~ts
@Controller()
export class UserController {
  constructor(private readonly userService: UserService) {}

  // 使用 this.userService 访问 UserService 的功能
}
~~~

这里的 `UserService` 会自动由 NestJS 创建，并且在需要的时候传递给 `UserController`。你不需要自己去管理这个过程。NestJS 的 IoC 容器就像一个自动化助手

- **自动创建对象** ：NestJS 会看到你在 UserController 中需要 UserService，然后它会自动创建一个 UserService 的实例。

- **自动注入依赖** ：NestJS 会把创建好的 UserService 实例自动传递给 UserController，你可以直接使用。

- **管理对象的生命周期** ：NestJS 会决定什么时候创建 UserService，什么时候销毁它，你不需要关心这些细节。
 
### NestJs 中使用  `@Injectable()` 和 `@Inject()` 

在这之前要搞懂 两个单词的中文意思 `@Injectable()` 和 `@Inject()` 

- `@Injectable()` ：表示“这个类是可被注入的”。被标记为 `@Injectable()` 的类可以作为其他类的依赖被注入。
  
- `@Inject()`：表示“注入某个特定的依赖”。它允许你手动指定要注入的依赖。

到目前这里还是不太清除，举一个例子来更清楚这两个属性

首先注入 `@Injectable()` 来注册一个可被注入的类

~~~ts
import { Injectable } from "@nestjs/common";

@Injectable()
export class UserModule {
  name: string = "w";
  age: number = 12;

  get info() {
    return `${this.name}_${this.age}`;
  }
}
~~~

这里需要 `providers` 去告诉 NestJS 这个服务可以用于依赖注入。也就不仅需要 `Injectable` 还需要 `providers` 去注册这个服务
~~~ts
import { UserController } from "src/injectable/user.controller";
import { AppController } from "./app.controller";

import { Module } from "@nestjs/common";
import { UserModule } from "src/injectable/user.module";
import { UserController1 } from "src/injectable/user.controller1";

// nest 创建一个新的模块。这个模块是一个类，用 @Module 装饰器装饰
/**
 * @Module是一个装饰器，用于定义模块
 * 模块是组织代码的基本单元，它将相关的组件(控制器、服务器、提供者)组合在一起
 * Nest的模块系统是受Angular启动
 */
@Module({
  controllers: [AppController, UserController, UserController1],
  providers: [UserModule, { provide: "UserModule1", useClass: UserModule }],
})
export class AppModule {}
~~~

现在来看  UserController 和  UserController1 的使用

`UserController` 中注入 `UserModule` 因为 Injectable 进行了注入，用了providers 注册了 UserModule ，现在只要在装饰器里面参数 ts 声明的类型进行形成了匹配，Nestjs 就会自动注入 UserModule 到 UserController 中


~~~ts
import { Controller, Get } from "@nestjs/common";
import { UserModule } from "./user.module";

@Controller("user")
export class UserController {
  // 注入到 User
  constructor(private readonly user: UserModule) {}

  @Get("/info")
  getInfo() {
    return this.user.info;
  }
}
~~~


在 `UserController1` 中，使用 `@Inject` 装饰器手动指定要注入的依赖项。这种方式允许更灵活的依赖项注入，尤其是在依赖项通过字符串标识（通常在提供者模式下）时。@Inject 装饰器会告诉 NestJS 需要从依赖注入容器中获取对应的依赖，并将其注入到指定的属性中。 可以**理解为指定映射注入**

~~~ts
import { Controller, Get, Inject } from "@nestjs/common";

@Controller("user1")
export class UserController1 {
  // 注入到 User

  @Inject("UserModule1")
  // 也可以这样 本质其实  providers: [UserModule] = 》providers: [{ provide: UserModule, useClass: UserModule }]
	// @Injectable(UserModule)
  private readonly user;
	// 也可以这样
  // constructor(@Inject("UserModule1") private readonly user) {}

  @Get("/info")
  getInfo() {
    return this.user.info;
  }
}
~~~

两者对比来看 在 UserController 的构造器里参数里声明了 UserModule 的依赖，就会自动注入，但有时如果在构造函数传参去定义的一些接口或者 父类 或者起了别名 这种形式 就需要使用 `@Inject` 去指定要注入的依赖项。 在是否需要使用 `@Inject` 取决于如果你的类没有扩展另一个类，那么你应该始终更喜欢使用基于构造函数的注入。构造函数明确概述了所需的依赖，并提供比使用 `@Inject` 注释的类属性更好的可见性。


### NestJs 中使用  `providers` 

在 NestJS 中，**providers** 是服务或依赖项的核心概念，主要用于依赖注入 (Dependency Injection, DI)。它们可以是类、值、工厂函数或异步工厂，NestJS 通过 DI 容器(是一种设计模式，允许一个类在不直接构造依赖对象的情况下接收它所依赖的对象)将这些提供者注入到需要它们的地方，如控制器或其他服务中。


在 NestJS 中，`providers` 是一个用于配置和注册服务的数组。每个服务都有一个 `provide` 属性，用于指定服务的标识符。



#### 使用类作为 Provider

直接通过构造函数注入,参考 `nest-demo\src\injectable\user.module.ts`

~~~ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  findAll() {
    return [];
  }
}

~~~
在模块中注册这个服务：
~~~ts
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({  
	controllers: [AppController, UserController, UserController1],
  providers: [UsersService], // 等同 [{ provide: UsersService, useClass: UserModule }]
})
export class UsersModule {
}
~~~

* 使用注入，在构造函数中注入依赖，当然也可以使用 Inject 通过标识指定依赖
~~~ts
import { Controller, Get, Inject } from "@nestjs/common";
import { UserModule } from "./user.module";

@Controller("user")
export class UserController {
  // 注入到 User
  // @Inject(UserModule)
  // private readonly user;
  constructor(private readonly user: UserModule) {}

  @Get("/info")
  getInfo() {
    return this.user.info;
  }
}
~~~

#### 提供器令牌 provide

useValue 来标注要注入的映射，案例 `apps\nest-demo\src\injectable\user.controller1.ts`
~~~ts
import { Injectable } from "@nestjs/common";

@Injectable()
export class UserModule {
  name: string = "w";
  age: number = 12;

  get info() {
    return `${this.name}_${this.age}`;
  }
}

~~~
~~~ts
// controller 用来处理请求
import { UserController } from "src/injectable/user.controller";
import { AppController } from "./app.controller";

import { Module } from "@nestjs/common";
import { UserModule } from "src/injectable/user.module";
import { UserController1 } from "src/injectable/user.controller1";

// nest 创建一个新的模块。这个模块是一个类，用 @Module 装饰器装饰
/**
 * @Module是一个装饰器，用于定义模块
 * 模块是组织代码的基本单元，它将相关的组件(控制器、服务器、提供者)组合在一起
 * Nest的模块系统是受Angular启动
 */
@Module({
  controllers: [AppController, UserController, UserController1],
	// 	const configServiceProvider = {
	//   provide: ConfigService,
	//   useClass:
	//     process.env.NODE_ENV === 'development'
	//       ? DevelopmentConfigService
	//       : ProductionConfigService,
	// };
  providers: [{ provide: "UserModule1", useClass: UserModule }],
})
export class AppModule {}
~~~

* 通过提供的 useValue 注入
~~~ts
import { Controller, Get, Inject } from "@nestjs/common";

@Controller("user1")
export class UserController1 {
  // 注入到 User

  @Inject("UserModule1")
  private readonly user;
  // constructor(@Inject("UserModule1") private readonly user) {}

  @Get("/info")
  getInfo() {
    return this.user.info;
  }
}
~~~


#### 使用工厂函数注入

可能需要动态创建 `provider` 。此时可以使用工厂函数 配合属性 `useFactory`, 参考 `apps\nest-demo\src\injectable\user.controller2.ts`

~~~ts
import { Injectable } from "@nestjs/common";

@Injectable()
export class UserModule1 {
  constructor(public name: string, public age: number) {
    this.name = "w";
    this.age = 12;
  }

  get info() {
    return `${this.name}_${this.age}`;
  }
}
~~~

~~~ts
// controller 用来处理请求
import { UserController } from "src/injectable/user.controller";
import { AppController } from "./app.controller";

import { Module } from "@nestjs/common";
import { UserModule } from "src/injectable/user.module";
import { UserController1 } from "src/injectable/user.controller1";
import { UserModule1 } from "src/injectable/user.module1";
import { UserController2 } from "src/injectable/user.controller2";

// nest 创建一个新的模块。这个模块是一个类，用 @Module 装饰器装饰
/**
 * @Module是一个装饰器，用于定义模块
 * 模块是组织代码的基本单元，它将相关的组件(控制器、服务器、提供者)组合在一起
 * Nest的模块系统是受Angular启动
 */
@Module({
  controllers: [
    AppController,
    UserController,
    UserController1,
    UserController2,
  ],
  providers: [
   
    {
      provide: "UserModule2",
      useFactory: () => {
        return new UserModule1("w", 22);
      },
    },
  ],
})
export class AppModule {}
~~~

~~~ts
import { Controller, Get, Inject } from "@nestjs/common";

@Controller("user2")
export class UserController2 {
  // 注入到 User

  @Inject("UserModule2")
  private readonly user;
  // constructor(@Inject("UserModule1") private readonly user) {}

  @Get("/info")
  getInfo() {
    return this.user.info;
  }
}
~~~

#### 更复杂工厂函数注入

这就需要引入一个新的参数 `inject` ,举个例子如果你在 `inject` 数组中指定了一个类（例如 `AnotherClass` ），那么这个类必须已经在模块的 `providers` 数组中注册。

这样工厂函数就能注入参数进行使用

~~~ts
providers: [
  AnotherClass, // 需要在这里提供 AnotherClass
  {
    provide: 'SomeComplexProvider',
    useFactory: (anotherProvider: AnotherClass) => {
      // 这里的 anotherProvider 会是 AnotherClass 的实例

    },
    inject: [AnotherClass] // [{token:AnotherClass,optional :true}],
  },
]
~~~
这里对新的参数  inject 做一个说明 可以是一个对象有两个参数

**token 是依赖的标识符，用来标识要注入的提供者**。
**optional 是一个布尔值（true 或 false），用来指定这个依赖项是否是可选的**。 `true` : 如果这个依赖项在 DI 容器中没有找到，NestJS 不会抛出错误，而是将 undefined 注入到工厂函数的相应参数中。 `false` : （默认值）如果没有找到这个依赖项，NestJS 会抛出错误，提示依赖项未解析。

*  一个完整的案例
~~~ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class OptionsProvider {
  get() {
    return {
      host: 'localhost',
      port: 5432,
      user: 'admin',
      password: 'password',
    };
  }
}
~~~

定义 一个模拟了数据库连接的行为 的类
~~~ts
export class DatabaseConnection {
  constructor(private options: any) {
    console.log('Database connected with options:', options);
  }

  query(sql: string) {
    // 假设这是一个执行 SQL 查询的简单方法
    console.log(`Executing query: ${sql}`);
    return [];
  }
}
~~~

~~~ts
import { Controller, Get, Inject } from '@nestjs/common';

@Controller()
export class AppController {
  constructor(
    @Inject('CONNECTION') private readonly dbConnection: DatabaseConnection
  ) {}

  @Get()
  getData() {
    // 使用数据库连接执行查询
    this.dbConnection.query('SELECT * FROM users');
    return 'Query executed';
  }
}
~~~

~~~ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { OptionsProvider } from './options.provider';
import { DatabaseConnection } from './database.connection';

@Module({
  controllers: [AppController],
  providers: [
    OptionsProvider,
    {
      provide: 'CONNECTION',
      useFactory: (
        optionsProvider: OptionsProvider,
        optionalProvider?: string
      ) => {
        const options = optionsProvider.get();

        if (optionalProvider) {
          console.log('Optional provider exists:', optionalProvider);
          options.extraOption = optionalProvider;
        } else {
          console.log('Optional provider does not exist');
        }

        return new DatabaseConnection(options);
      },
      inject: [
        OptionsProvider, 
        { token: 'SomeOptionalProvider', optional: true }
      ],
    },
    // Uncomment the following line to provide the optional provider
    // { provide: 'SomeOptionalProvider', useValue: 'Optional Value' },
  ],
})
export class AppModule {}
~~~

#### useExisting 提供别名

`useExisting` 是 NestJS 提供的一种配置方式，用于为现有的提供者创建别名。这意味着你可以通过多个标识符来引用同一个提供者实例,这种方法不会创建新的实例，而是让别名提供者和原提供者指向同一个实例

~~~ts
import { Injectable } from '@nestjs/common';

@Injectable()
class LoggerService {
  log(message: string) {
    console.log('LoggerService:', message);
  }
}
~~~

* 使用别名

~~~ts
const loggerAliasProvider = {
  provide: 'AliasedLoggerService',
  useExisting: LoggerService,
};
~~~

* 注册
~~~ts
import { Module } from '@nestjs/common';

@Module({
  providers: [LoggerService, loggerAliasProvider],
})
export class AppModule {}
~~~

#### 其他注入基本类型

~~~ts
@Module({
  providers: [
    {
      provide: 'APP_NAME',
      useValue: 'MyApp',
    },
  ],
})
export class AppModule {}
~~~