---
description: api分析_Controller
---

接下来要看 Controller 在 nest 上 api 说明后进一步实现 `NestApplication` 中的转发 实现细节

首相 nest cli 提供了生成 controller 的命令想要生成 `nest g controller [name]`, 在 express 中我们使用 `res.send` 进行发送内容，这里有个说明 `res.send([body])` **body 发送一个 HTTP 响应。针对不同类型的数据采用适当的响应头**。

1. **Buffer 对象**：

   - 如果 `body` 是一个 `Buffer` 对象，`res.send()` 会将其直接发送，并将 `Content-Type` 设置为 `application/octet-stream`（除非你手动设置了其他类型）。
   - 例如：

     ```javascript
     res.send(Buffer.from("whoop"));
     ```

     这将发送原始的二进制数据。

2. **字符串**：

   - 如果 `body` 是一个字符串，`res.send()` 会将 `Content-Type` 自动设置为 `text/html`，因为字符串通常表示 HTML 内容。
   - 例如：

     ```javascript
     res.send("<p>some html</p>");
     // res.status(404).send('Sorry, we cannot find that!');
     ```

     这将发送一段 HTML 内容。

3. **对象或数组**：

   - 如果 `body` 是一个对象或数组，`res.send()` 会自动将其转换为 JSON 格式，并将 `Content-Type` 设置为 `application/json`。
   - 例如：

     ```javascript
     res.send({ user: "tobi" });
     res.send([1, 2, 3]);
     ```

     这些都会发送 JSON 数据。

4. **布尔值**：
   - 如果传入一个布尔值，`res.send()` 会将它作为字符串 `true` 或 `false` 发送，并将 `Content-Type` 设置为 `text/html`。

## controller 响应

- 当它返回 JavaScript 基本类型（例如 string、 number、 boolean）时，Nest 将仅发送该值，而不尝试对其进行序列化

- 一般情况下，响应的状态代码始终为 200，但使用 201 的 POST 请求除外。我们可以通过在处理程序级别添加 @HttpCode(...)

- 但要注意的是 如果在 nest 中 当你使用` @Res()` 或 `@Response()` 装饰器时，你需要手动管理响应的发送，这种做法 `就抛离的nestjs` 这种分发可以将 `passthrough` 选项设置为 `true`，这样即使用了 ` @Res()` 或 `@Response()` 装饰器时 依旧可以用**return nextjs 帮助分发**

- 如果使用了 @Next() 装饰器 需要调用 next 用于调用下一个中间件或处理程序。

**这将会影响 通过 nest 自动通过 return 将会失效的案例**

```ts
import { Controller, Get, Post, Res, HttpCode, Next } from "@nestjs/common";
import { Response, NextFunction } from "express";

@Controller("example")
export class ExampleController {
  // 错误使用 @Res 导致响应未被正确发送
  @Get()
  handleGetRequest(@Res() res: Response) {
    // 手动设置状态码并发送响应
    res.status(200).send("Hello, world!");

    // 此时如果再返回一个值，将不会被发送
    // return 'This will be ignored by NestJS';
  }

  // 错误使用 @Res 但未处理响应
  @Post()
  @HttpCode(200)
  handlePostRequest(@Res() res: Response) {
    // 手动设置响应头
    res.header("X-Custom-Header", "CustomValue");

    // 错误：未发送响应，导致客户端挂起
    // 由于使用了 @Res，NestJS 不会自动发送响应
    // 必须手动调用 res.send()
  }

  @Get("next")
  handleWithNext(@Next() next: NextFunction) {
    console.log("Before calling the next middleware or handler.");
    next(); // 调用下一个中间件或处理程序
  }
}
```

**使用了上面说到装饰器还想让 nest 机制托管的话**

```ts
import { Controller, Get, Post, Res, HttpCode, Next } from "@nestjs/common";
import { Response, NextFunction } from "express";

@Controller("example")
export class ExampleController {
  // 正确使用 @Res 和 @HttpCode
  @Get()
  handleGetRequest(@Res({ passthrough: true }) res: Response) {
    // 手动设置 Cookie
    res.cookie("key", "value");

    // 返回一个字符串，NestJS 将自动处理并发送
    return "Hello, world!";
  }

  // 正确使用 @HttpCode
  @Post()
  @HttpCode(201)
  handlePostRequest(@Res({ passthrough: true }) res: Response) {
    // 手动设置响应头
    res.header("X-Custom-Header", "CustomValue");

    // 返回一个 JSON 对象，NestJS 将自动序列化并发送
    return { message: "Created successfully!" };
  }

  // 正确使用 @Next 调用下一个中间件或处理程序
  @Get("next")
  handleWithNext(@Next() next: NextFunction) {
    console.log("Before calling the next middleware or handler.");
    next(); // 调用下一个中间件或处理程序
    console.log("After calling the next middleware or handler.");
  }
}
```

### controller 层使用的装饰器

我们只要做的就是将装饰器  和 express 的参数 进行映射。这就是我们装饰器的设计

| 装饰器                    | 对应 Express 对象/属性              | 说明                                                                          |
| ------------------------- | ----------------------------------- | ----------------------------------------------------------------------------- |
| `@Request()` / `@Req()`   | `req`                               | 注入整个请求对象，包含请求的所有信息。                                        |
| `@Response()` / `@Res()`  | `res`                               | 注入响应对象，允许直接控制响应的发送。                                        |
| `@Next()`                 | `next`                              | 注入 `next` 函数，用于调用下一个中间件或路由处理程序。                        |
| `@Session()`              | `req.session`                       | 注入会话对象，允许访问或修改当前请求的会话数据。                              |
| `@Param(key?: string)`    | `req.params` / `req.params[key]`    | 注入路由参数，若指定 `key` 则注入特定的路由参数，否则注入整个参数对象。       |
| `@Body(key?: string)`     | `req.body` / `req.body[key]`        | 注入请求体数据，若指定 `key` 则注入特定的请求体字段，否则注入整个请求体对象。 |
| `@Query(key?: string)`    | `req.query` / `req.query[key]`      | 注入查询参数，若指定 `key` 则注入特定的查询参数，否则注入整个查询参数对象。   |
| `@Headers(name?: string)` | `req.headers` / `req.headers[name]` | 注入请求头，若指定 `name` 则注入特定的请求头值，否则注入整个请求头对象。      |
| `@Ip()`                   | `req.ip`                            | 注入请求的客户端 IP 地址。                                                    |
| `@HostParam()`            | `req.hosts`                         | 注入请求的主机参数。                                                          |
| `@Get()`                  | N/A                                 | 定义处理 GET 请求的路由处理程序。                                             |
| `@Post()`                 | N/A                                 | 定义处理 POST 请求的路由处理程序。                                            |
| `@Put()`                  | N/A                                 | 定义处理 PUT 请求的路由处理程序。                                             |
| `@Delete()`               | N/A                                 | 定义处理 DELETE 请求的路由处理程序。                                          |
| `@Patch()`                | N/A                                 | 定义处理 PATCH 请求的路由处理程序。                                           |
| `@Options()`              | N/A                                 | 定义处理 OPTIONS 请求的路由处理程序。                                         |
| `@Head()`                 | N/A                                 | 定义处理 HEAD 请求的路由处理程序。                                            |
| `@All()`                  | N/A                                 | 定义处理所有 HTTP 请求方法的路由处理程序。                                    |


## 开始实现

首先实现装饰器，用来收集 这部分装饰器主要分为 类装饰器 ， 方法装饰器 ， 参数装饰器。

### 实现 @Controller 装饰器


`@Controller` 是 NestJS 框架中的一个装饰器，用于定义控制器类。控制器是处理传入请求并返回响应的类，通常会与一个特定的路由或一组相关的路由关联。

1. **定义控制器类**：
   - 使用 `@Controller` 装饰器可以将一个类标记为 NestJS 控制器。这个类中的方法将处理由该控制器负责的路由请求。

2. **路由前缀**：
   - `@Controller` 可以接受一个可选参数，该参数定义了控制器的路由前缀。例如，`@Controller('users')` 将把这个控制器中的所有路由都加上 `/users` 前缀。比如，如果控制器中有一个处理 `GET /` 请求的方法，那么该方法实际会处理 `GET /users` 请求。

3. **路由映射**：
   - 控制器中的方法通过 `@Get()`、`@Post()`、`@Put()` 等装饰器来映射到特定的 HTTP 请求方法和路径上。例如，`@Get('profile')` 将方法映射到 `GET /users/profile` 路由上（假设控制器的前缀为 `users`）。

4. **组织代码**：
   - `@Controller` 帮助组织和管理应用程序的路由和逻辑，将不同功能的路由集中在一起，使代码更模块化、易维护。


#### 伪代码实现

代码位置 `\packages\@nestjs\common\controller.decorator.ts`

1. 这里定义了 Controller 函数的三个重载版本：
   - 无参数：Controller()，不传递任何参数。
   - 字符串参数：Controller(prefix: string)，传递一个字符串作为路径前缀。
   - 对象参数：Controller(options: ControllerOptions)，传递一个对象，可能包含路径前缀。
`prefixOrOptions` 参数可以是 string 类型或者 `ControllerOptions` 对象。如果 `prefixOrOptions` 是字符串，则将其作为 options.prefix。如果 `prefixOrOptions` 是对象（即 ControllerOptions），则将其赋值给 `options`

1. 装饰器收集映射 `Reflect.defineMetadata` 是一个用来定义元数据的函数。元数据是一种可以附加到类或类成员（如属性、方法）的信息，可以在运行时使用反射机制读取这些信息。在这里，`Reflect.defineMetadata('prefix', options.prefix || '', target)` 的意思是
   - 为控制器类 target 添加一个元数据，键名为 'prefix'，值为 options.prefix 或者空字符串（如果 prefix 未定义）。

   - 这个元数据表示控制器的路由前缀，可以在框架的其他部分使用它来生成完整的路由路径。
也就是可以通过 prefix 字符串 + 配置的实际路由 可以映射出 **controller 构造函数**
~~~ts
interface ControllerOptions {
	prefix?: string
}
//其实可能给Controller传递路径路径前缀
//前缀前缀可以为空,也可写成空串，也可以写一个非空字符串，也可能写成一个对象
export function Controller(): ClassDecorator //传空串
export function Controller(prefix: string): ClassDecorator //路径前缀
export function Controller(options: ControllerOptions): ClassDecorator //传递对象
export function Controller(
	prefixOrOptions?: string | ControllerOptions
): ClassDecorator {
	let options: ControllerOptions = {}
	if (typeof prefixOrOptions === 'string') {
		options.prefix = prefixOrOptions
	} else if (typeof prefixOrOptions === 'object') {
    options = prefixOrOptions;
  }

	//这是一个类装饰器，装饰的控制器这个类
	return (target: Function) => {
		//给控制器类添加prefix路径前缀的元数据
		Reflect.defineMetadata('prefix', options.prefix || '', target)
	}
}
~~~

* 举例子说明
`prefix 字符串 + /users` 会映射 UserController，`prefix 字符串 + /products` 会映射 ProductController,`prefix 字符串 + 空` 会映射 HomeController
~~~ts
@Controller('users')
export class UserController {
  // 控制器中的路由将会有一个前缀 `/users`
}

@Controller({ prefix: 'products' })
export class ProductController {
  // 控制器中的路由将会有一个前缀 `/products`
}

@Controller()
export class HomeController {
  // 控制器中的路由没有前缀
}
~~~

### 实现修饰在方法上的装饰器

修饰在方法的装饰器