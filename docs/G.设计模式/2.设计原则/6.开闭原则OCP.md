---
description: 开闭原则OCP，对扩展开放，对修改封闭，通过抽象化和多态来实现。
---

开闭原则的英文全称是 `Open Closed Principle`，简写为 `OCP`。它的英文描述是：`software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification`。中文意思：**软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”**。

通俗话理解**添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）** 这个程度可以理解为（当增加了新功能，原代码的功能可以在不修改测试代码的情况下继续测试，新的功能只要新增测试用例就可以）

### 扩展和修改

开闭原则可以应用在不同粒度的代码中，可以是**模块，也可以类，还可以是方法（及其属性）**。同样一个代码改动

在粗代码粒度下，被认定为**修改**

在细代码粒度下，又可以被认定为**扩展**，例如，**添加属性和方法相当于修改类，在类这个层面**，这个代码改动可以被认定为**修改**；**但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面**，它又可以被认定为**扩展**


也可以理解为**修改**还是**扩展** 取决于 **不破坏原有代码，对原有代码的侵入最低，可以说是基于扩展而不是修改**或者说 **只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试**


 ## 案例代码
中举了一个案例一段 API 接口监控告警的代码业务逻辑主要集中在 `check()` 函数中。当接口的 `TPS `超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队
~~~java

public class Alert {
	private AlertRule rule; // 存储告警规则
	private Notification notification;

	// 收集规则
	public Alert(AlertRule rule, Notification notification) {
		this.rule = rule;
		this.notification = notification;
	}

	/**
	 * 
	 * @param api               接口
	 * @param requestCount      请求数量
	 * @param errorCount        错误数量
	 * @param durationOfSeconds 持续时间
	 */
	public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {

		// 计算 服务器每秒处理的事务数
		long tps = requestCount / durationOfSeconds;

		// 处理的事务数tps 大于 传入规则 收集
		if (tps > rule.getMatchedRule(api).getMaxTps()) {
			// NotificationEmergencyLevel
			// 表示通知的紧急程度其中SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）
			notification.notify(NotificationEmergencyLevel.URGENCY, "...");
		}

		// 报错条数 大于 传入规则 收集
		if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
			notification.notify(NotificationEmergencyLevel.SEVERE, "...");
		}
	}
}
~~~
