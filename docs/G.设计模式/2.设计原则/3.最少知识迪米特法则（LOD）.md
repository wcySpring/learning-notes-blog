---
description: 最少知识迪米特法则（LOD），一个对象应该对其他对象保持最少的了解，尽量降低类与类之间的耦合。
---
**迪米特法则**：也叫`最少知识原则`，是一种面向对象设计原则，也称为迪米特法则（Principle of Least Knowledge，简称 POLA），该原则的核心思想是：一个对象应该对其他对象有尽可能少的了解如果两个类不必彼此直接通信，那这两个类就不应该发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。

迪米特法则首先强调的前提是在类的结构设计上，每一个类都尽量降低成员的访问权限，也就是说一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。迪米特法则的根本思想是强调类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及，也就是信息的隐藏促进了软件的复用。

**因此该原则的核心思想是**：一个对象应该对其他对象有尽可能少的了解，只与其直接的朋友通信。直接的朋友是指当前对象本身、被当做参数传入的对象、当前对象所创建或实例化的对象以及其组件。这样可以降低对象之间的耦合度，提高代码的可维护性和可重用性。
  
 ## 购物案例
假设一个在超市购物的场景：顾客选好商品后，到收银台找收银员结账。这里我们定义一个顾客类（Customer）、收银员类（PaperBoy ）、钱包类（Wallet ），示例代码如下(逻辑是 收银员获取顾客钱包，从顾客钱包中检查钱是否够支付的，够就从钱包拿钱，不够就是就把钱包还给顾客)

~~~java
//顾客

public class Customer {

    private String firstName;

    private String lastName;

    private Wallet myWallet;

    public String getFirstName(){

        return firstName;

    }

    public String getLastName(){

        return lastName;

    }

    public Wallet getWallet(){

        return myWallet;

    }

}

//钱包类

public class Wallet {

    private float value;

    public float getTotalMoney() {

        return value;

    }

    public void setTotalMoney(float newValue) {

        value = newValue;

    }

    public void addMoney(float deposit) {

        value += deposit;

    }

    public void subtractMoney(float debit) {

        value -= debit;

    }

}

//收银员

public class Paperboy {

    public void charge(Customer myCustomer, float payment) {

        payment = 2f;

        Wallet theWallet = myCustomer.getWallet();

        if (theWallet.getTotalMoney() > payment) {

            theWallet.subtractMoney(payment);

        } else {

            //钱不够的处理

        }

    }

}

~~~
* 逻辑看似荒诞收银员去哪了顾客的钱包进行了支付，但违背了**迪米特法则**，`收银员的类`完全没必要和`钱包类`进行通信，如果非要使用`钱包类` 应该是通过第三者转发，钱包属于顾客，顾客才能作为中转使用钱包。因此这种在 Paperboy 类中，它直接调用了 Customer 类的 getWallet 方法，这样就导致了 Paperboy 类和 Customer 类之间的耦合度过高，这种耦合过高因为 Paperboy 类需要了解 Customer 类的内部实现，即它需要知道 Customer 类中有一个名为 getWallet 的方法，而且这个方法返回的是一个 Wallet 对象。这样就使得 Paperboy 类和 Customer 类之间的关系变得紧密，一旦 Customer 类的实现发生变化，就可能会影响到 Paperboy 类的实现。

* 按照最少知识迪米特法则的原则，Paperboy 类只应该调用 Customer 类的公共方法，而不应该了解它的内部实现，实现我们可以在顾客类中增加一个公共方法用来付钱`myCustomer.pay`


~~~java
//顾客

public class Customer {

	private String firstName;

	private String lastName;

	private Wallet myWallet;

	public String getFirstName() {

		return firstName;

	}

	public String getLastName() {

		return lastName;

	}

	public Wallet getWallet() {

		return myWallet;

	}

	public float pay(float bill) {
		// if (myWallet != null) {
		// 	if (myWallet.getTotalMoney() > bill) {
		// 		myWallet.subtractMoney(bill);
		// 		return bill;
		// 	}
		// }
		// return 0;
		return wallet.subtractMoney(amount)
	}

}

// 钱包类

public class Wallet {

	private float value;

	public float getTotalMoney() {

		return value;

	}

	public void setTotalMoney(float newValue) {

		value = newValue;

	}

	public void addMoney(float deposit) {

		value += deposit;

	}

	public void subtractMoney(float debit) {

		value -= debit;

	}
	// 扣除金额
	public float subtractMoney(float amount) {
			if (totalMoney >= amount) {
					totalMoney -= amount;
					return amount;
			} else {
					return 0;
			}
	}

}

// 收银员

public class PaperBoy {

	public void charge(Customer myCustomer, float payment {

        payment = 2f; // “我要收取2元!”

        float paidAmount = myCustomer.pay(payment);

        if (paidAmount == payment) {

            // 说声谢谢，欢迎下次光临

        } else {

            // 可以稍后再来

        }

    }

}

~~~

## 总结

当一个对象需要调用另一个对象的方法时，最少知识迪米特法则建议只调用以下几种对象的方法：

1. 当前对象本身的方法：当前对象可以直接调用自己的方法，因为它们是同一个对象，不存在耦合问题。

2. 作为参数传递给当前对象的对象的方法：当前对象可以调用作为参数传递给它的对象的公共方法，因为这些方法是公共的，不会影响到对象之间的耦合关系。

3. 当前对象所创建或实例化的对象的方法：当前对象可以调用它所创建或实例化的对象的公共方法，因为这些对象是由当前对象创建或实例化的，不存在耦合问题。

4. 当前对象的组件的方法：当前对象可以调用它的组件的公共方法，因为组件是当前对象的一部分，不存在耦合问题。

这样可以避免对象之间的紧密耦合，降低代码的复杂度和维护成本。同时，这也符合单一职责原则和开闭原则的要求，使得代码更加灵活和易于扩展。


以上面对例子带入来看

1. Paperboy 类只调用 Customer 类的 getWallet 方法，获取顾客的钱包对象，而不需要了解钱包对象的内部实现。
2. Paperboy 类只调用 Wallet 类的 getTotalMoney 和 subtractMoney 方法，获取钱包的余额和扣除金额，而不需要了解钱包对象的内部实现。
3. Customer 类只调用 Wallet 类的公共方法，获取钱包的余额和扣除金额，而不需要了解钱包对象的内部实现。


这样，代码遵循了最少知识迪米特法则的原则，降低了对象之间的耦合度，提高了代码的可维护性和可重用性。同时，也符合单一职责原则和开闭原则的要求，使得代码更加灵活和易于扩展。

## 应用
[门面模式](https://baike.baidu.com/item/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/764642?fromModule=lemma_inlink)

（[Facade](https://baike.baidu.com/item/Facade/2954918?fromModule=lemma_inlink)）和中介模式（Mediator），都是迪米特法则应用的例子
