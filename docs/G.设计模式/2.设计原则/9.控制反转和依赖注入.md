---
description: 依赖注入（Dependency Injection, DI）和控制反转（Inversion of Control, IoC）是软件工程中重要的设计原则和模式，它们有助于提高代码的可维护性、可测试性和灵活性
--- 
先从概念的大维度来看 `IOC（控制反转）Inversion of Control）` 和 `DI（依赖注入）（Dependency Injection）`

IOC（控制反转）Inversion of Control） 是一种**设计原则**，用于减少代码之间的耦合。传统的编程方式中，程序直接控制其所依赖的对象的创建和管理，而使用 IOC 时，对象的创建和管理权被反转给了容器或框架。程序不再主动创建对象，而是被动接收由容器或框架注入的对象

DI（依赖注入）（Dependency Injection）是实现 IOC 的一种手段。通过 DI，我们可以将类的依赖项（即它所需要的对象）注入到类中，而不是在类内部创建这些依赖项。这样可以使得类更加易于测试、维护和扩展。

依赖注入（Dependency Injection，简称 DI），是用于实现 IoC 的**设计模式**。简单来说，它允许在类之外创建依赖对象，并通过不同方式将这些对象提供给类

在概念上 可以看到两者其实并不是一个维度上的东西，分别是 **设计原则** 和  **设计模式**

| 维度       | 设计原则                                       | 设计模式                                       |
|------------|------------------------------------------------|------------------------------------------------|
| 抽象层次   | 抽象层次较高，提供高层次的指导原则。           | 抽象层次较低，提供具体的解决方案。             |
| 应用范围   | 适用于各种软件设计和开发场景，不特定于任何编程语言或框架。 | 特定于具体的编程语言或框架，解决特定的问题。   |
| 具体性     | 通常是抽象的，不提供具体的实现细节。           | 提供具体的实现细节，可以直接应用于代码中。     |

## IOC（控制反转）

控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计，因此能遵循的控制反转设计原则具体实现的设计模式 `依赖注入模式`  `服务定位器模式`  `模板模式` `策略模式` 等 这类带来优势显而易见

- 将任务的执行与任务的实现分离开来
- 更容易在不同的实现之间切换
- 程序的模块化程度更高
- 通过隔离组件或模拟其依赖，并允许组件通过 “约定” 进行通信，从而更轻松地测试程序

控制对象生命周期的不再是引用它的对象，而是容器，这就叫控制反转举个例子 创建工厂类
~~~java
public class ActionFactory {
    public static Action getAction(String condition) {
        if ("A".equals(condition)) {
            return new ActionA();
        } else if ("B".equals(condition)) {
            return new ActionB();
        } else {
            throw new IllegalArgumentException("Unknown condition");
        }
    }
}
~~~
在使用的时候
~~~java
public class Main {
    public static void main(String[] args) {
        String condition = "A"; // 可以根据实际情况动态设置

        Action action = ActionFactory.getAction(condition);
        action.execute();
    }
}
~~~
ActionFactory根据条件返回不同的实现类实例，从而将创建具体实现类的责任从主代码中分离出来。通过工厂类获取具体的实现类，并调用其方法，而不需要直接创建和调用具体的实现类。这种方式实现了控制反转，因为控制权从主代码转移到了工厂类，主代码不再负责创建和管理具体实现类的实例。

## DI（依赖注入）

依赖注入（DI），是一种设计模式,将依赖通过 注入 的方式提供给需要的类。一般来讲，主要有三种方式来注入类：**通过构造函数**、**设值方法注入**和**接口注入** （不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。）。 有的也可以通过装饰器注入。

构造函数注入和设值方法注入是最常见的两种方式，而注解注入则通常与依赖注入框架结合使用，以简化依赖关系的声明和管理。选择哪种方式取决于具体的应用需求和设计目标。

往往依赖注入和控制反转搭配在一起，IoC 容器（又叫作 DI 容器），是用于实现自动依赖注入的框架。它的作用是管理对象的创建及其生命周期，并提供向类注入依赖项的具体实现，这样做是为了我们不必手动创建和管理对象。

### 对比案例

分别用依赖注入和非依赖注入两种方式来实现一下
~~~java
public class Notification {
  private MessageSender messageSender;
  
  public Notification() {
    this.messageSender = new SmsSender(); // 直接实例化具体的MessageSender实现类
  }
  
  public void sendMessage(String cellphone, String message) {
    this.messageSender.send(cellphone, message);
  }
}

public interface MessageSender {
  void send(String cellphone, String message);
}

// 短信发送类
public class SmsSender implements MessageSender {
  @Override
  public void send(String cellphone, String message) {
    //....
  }
}

// 站内信发送类
public class InboxSender implements MessageSender {
  @Override
  public void send(String cellphone, String message) {
    //....
  }
}

//使用Notification
Notification notification = new Notification();
~~~

通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类，就像下面的案例

~~~java
public class Notification {
  private MessageSender messageSender;
  
  public Notification(MessageSender messageSender) {
    this.messageSender = messageSender;
  }
  
  public void sendMessage(String cellphone, String message) {
    this.messageSender.send(cellphone, message);
  }
}

public interface MessageSender {
  void send(String cellphone, String message);
}

// 短信发送类
public class SmsSender implements MessageSender {
  @Override
  public void send(String cellphone, String message) {
    //....
  }
}

// 站内信发送类
public class InboxSender implements MessageSender {
  @Override
  public void send(String cellphone, String message) {
    //....
  }
}

//使用Notification
MessageSender messageSender = new SmsSender();
Notification notification = new Notification(messageSender);
~~~

#### 构造函数注入

~~~java
public class MyService {
    private final Dependency dependency;

    public MyService(Dependency dependency) {
        this.dependency = dependency;
    }

    public void execute() {
        dependency.doSomething();
    }
}

public class Dependency {
    public void doSomething() {
        System.out.println("Doing something");
    }
}

public class Main {
    public static void main(String[] args) {
        Dependency dependency = new Dependency();
        MyService myService = new MyService(dependency);
        myService.execute();
    }
}
~~~

#### 设值方法注入（Setter Injection）

~~~java
public class MyService {
    private Dependency dependency;

    public void setDependency(Dependency dependency) {
        this.dependency = dependency;
    }

    public void execute() {
        dependency.doSomething();
    }
}

public class Dependency {
    public void doSomething() {
        System.out.println("Doing something");
    }
}

public class Main {
    public static void main(String[] args) {
        Dependency dependency = new Dependency();
        MyService myService = new MyService();
        myService.setDependency(dependency);
        myService.execute();
    }
}
~~~

####  接口注入（Interface Injection）

在接口注入中，依赖关系通过实现一个特定的接口来传递。这种方式相对较少使用，因为它增加了额外的接口和实现类的复杂性。

~~~java
public interface InjectDependency {
    void injectDependency(Dependency dependency);
}

public class MyService implements InjectDependency {
    private Dependency dependency;

    @Override
    public void injectDependency(Dependency dependency) {
        this.dependency = dependency;
    }

    public void execute() {
        dependency.doSomething();
    }
}

public class Dependency {
    public void doSomething() {
        System.out.println("Doing something");
    }
}

public class Main {
    public static void main(String[] args) {
        Dependency dependency = new Dependency();
        MyService myService = new MyService();
        myService.injectDependency(dependency);
        myService.execute();
    }
}
~~~

## 总结

控制反转： 是一种设计原则，思想是反转应用程序的控制流，由框架来决定如何 call 你。

依赖注入： 是一种设计模式，控制反转的一种实现方式，它将依赖关系定义在外部而不是内部自行实例化，分离依赖项对象的创建和使用。

控制反转是一种设计思想，面向对象的一种设计原则，而依赖注入则是一种实现这个思想的一种手段。开头的图也是能直观的体现出来。

依赖注入实现了控制反转原则，即对象获得依赖关系不再自行控制，而是反转控制权给外部。

换句话说，通过依赖注入可以完成控制反转，而控制反转不一定用依赖注入实现。

