---
description: Monorepo（单体仓库）与 MultiRepo（多仓库）
tags:
  - Monorepo
  - MultiRepo
---
在软件开发的过程中，随着应用规模的增大和复杂性的提高，开发团队逐渐从单体应用（Monolith）演进到多仓库多模块应用（MultiRepo），再到单仓库多模块应用（Monorepo）。

## 演进过程

1. **初期：单体应用（Monolith）**
   - 适用于初期开发，简单直接，但随着应用规模增大，扩展性和维护性变差。
   
2. **中期：多仓库多模块应用（MultiRepo）**
   - 通过拆分模块，提升了灵活性和扩展性，但引入了依赖管理和代码共享的问题。
   
3. **现代：单仓库多模块应用（Monorepo）**
   - 结合了模块化的优势和统一代码库的便利，提升了代码共享和一致性，但也带来了新的挑战。

![](/images/2024-08-05-11-11-37.png)

## 单体应用（Monolith）

在软件开发的早期阶段，通常采用单体应用的开发模式。整个应用程序由一个单一的代码库、构建和部署流程组成。这种模式简单易懂，适合小型项目。

### 特点
- **单一代码库**：所有代码都存放在一个代码库中。
- **集中化架构**：应用的所有功能模块和组件都在一个应用中运行。
- **部署单元**：整个应用作为一个单元进行构建、测试和部署。

### 优点
- **简单性**：初期开发和部署简单，适合小型团队和项目。
- **一致性**：代码风格、依赖管理和构建过程一致。

### 缺点
- **扩展性差**：随着应用规模增大，代码库变得庞大且复杂，维护困难。
- **部署复杂**：任何小的更改都需要重新部署整个应用，风险大。
- **团队协作**：多个团队同时修改同一代码库，容易引发冲突。

## 多仓库多模块应用（MultiRepo）

为了解决单体应用的扩展性问题，团队开始将项目拆分为多个独立的仓库，每个仓库独立维护自己的代码和构建流程。这种模式更适合大型和复杂的项目，因为它提供了更好的隔离性和独立性，同时可以更灵活地管理多个团队的工作。

### 特点
- **多代码库**：每个模块或服务有独立的代码库。一个项目都有一个独立的仓库，职责单一
- **分布式架构**：应用被拆分为多个独立的服务或模块。
- **独立部署**：各个模块独立构建、测试和部署。

### 优点
- **模块化**：代码库分离，使得每个模块更加独立和易于管理。
- **灵活性**：不同模块可以独立开发、测试和部署，降低了整体风险。
- **团队协作**：不同团队可以分别负责不同模块，减少冲突。利于进行权限控制，可以针对单个仓库来分配权限，权限分配粒度比较细。

### 缺点
- **依赖管理**：跨模块的依赖关系管理复杂。模块越来越多，涉及多模块同时改动的场景增加。如何保障底层组件升级后，其引用到的组件也能同步更新到位。这点很难做到，如果没及时升级，各工程的依赖版本不一致，往往会引发一些意想不到的问题。
- **代码共享困难**：跨多个代码库共享代码和工具变得困难。假如多个工程依赖 pkg-a，那么每个工程下 node_modules 都会重复安装 pkg-a，对本地磁盘内存和本地启动都是个很大的挑战。而且每个模块的发布都是相对独立的，当一次迭代修改较多模块时，总体发布时效就是每个发布流程的串联。对发布者来说是一个非常大的负担。
- **一致性挑战**：保持不同代码库之间的风格和流程一致需要额外的努力。

## 单仓库多模块应用（Monorepo）
回归单体管理：Monorepo 是一种试图回归单体管理优势的方法，但保留了多仓库开发的某些优点。它允许在一个代码库中管理多个项目、组件或服务，提供更好的代码共享和重用性。


现代工具支持：现代的版本控制系统和工具链使得 Monorepo 开发模式更为可行，例如像 Pnpm、Yarn 、Lerna 和 Turborepo 等工具，它们提供了更好的管理、构建和部署多个项目的能力。

### 特点
- **单一代码库**：所有模块和服务的代码都存放在一个代码库中。
- **分布式架构**：与MultiRepo类似，应用被拆分为多个模块，但在同一个代码库中。
- **统一管理**：代码共享、依赖管理和构建工具在一个代码库中统一管理。

### 优点
- **代码共享**：模块之间的代码共享和重用更加方便。
- **一致性**：统一的代码风格、构建工具和测试框架，提升了开发一致性。
- **原子性更改**：跨多个模块的更改可以在一个提交中完成，确保更改的一致性和完整性。
- **简化依赖管理**：依赖关系在单一代码库中更容易管理和更新。

### 缺点
- **构建性能**：大型Monorepo的构建和测试时间可能较长，需要先进的构建工具支持。
- **代码冲突**：多个团队在同一个代码库中工作，可能会引发更多冲突。
- **权限管理**：需要更细粒度的权限管理机制，以确保不同团队对代码库的访问控制。
- **提交内容日志** ： 大家都在一个仓库了所以在提交日志上就会出现很多非自己负责项目日志查找


### 如何解决 monorepo 无法进行细粒度权限管理的缺点

#### 1. 使用代码所有权文件
使用如 CODEOWNERS 文件（GitHub 等平台支持）来指定某个目录或文件的所有者。当这些文件或目录被修改时，只有指定的所有者才能批准更改。这种方法能够实现对项目或模块级别的权限粒度控制。

#### 2. 利用 CI/CD 流程
在持续集成/持续部署（CI/CD）流程中设置权限和访问控制。例如，可以配置流程，只允许具有特定权限的用户触发构建或部署到生产环境。这种方式可以在流程层面上控制谁可以对代码库进行重要操作。

#### 3. 分支策略
通过严格的分支管理策略，如 Git Flow，控制不同级别的开发人员可以访问和修改的分支。比如只允许项目负责人合并代码到主分支，而其他开发人员只能在特定的功能分支上工作。

#### 4. 使用 Git 钩子
配置 Git 钩子（Hooks），在代码提交或合并前执行脚本来检查提交者的权限。例如，可以设定 pre-commit 钩子，确保提交的代码符合访问权限要求。

#### 5. 利用子模块
虽然这种做法在传统 monorepo 中较少使用，但通过 Git 子模块（submodules）可以实现对特定部分的仓库独立控制，从而在需要时提供更细粒度的权限管理。

#### 6. 第三方工具和扩展
考虑使用一些第三方工具和扩展来管理权限。例如，GitLab 和 Bitbucket 等平台提供了更细粒度的权限控制设置，允许在项目或组织级别进行详细的访问控制。
