---
description: 初步了解前端包管理工具pnpm
tags:
  - 工程化
  - pnpm
---


当使用 `npm` 或 `Yarn` 时，如果你有 100 个项目，并且所有项目都有一个相同的依赖包，那么， 你在硬盘上就需要保存 100 份该相同依赖包的副本,每个项目依赖包都是一个独立个体 `pnpm` 采用 依赖包将被 存放在一个统一的位置

pnpm 的特点

- 如果你对同一依赖包使用相同的版本，那么磁盘上只有这个依赖包的一份文件
- 如果你对同一依赖包需要使用不同的版本，则仅有 版本之间不同的文件会被存储起来
- 所有文件都保存在硬盘上的统一的位置，当安装软件包时， 其包含的所有文件都会硬链接到此位置，而不会占用 额外的硬盘空间，就可以在项目之间方便地共享相同版本的 依赖包；

![](/images/2024-07-31-16-32-42.png)

## 基本的常见等价指令
| 功能               | npm 指令                        | pnpm 指令                    |
| ------------------ | ------------------------------- | ---------------------------- |
| 安装依赖           | `npm install`                   | `pnpm install`               |
| 安装特定包         | `npm install <package-name>`    | `pnpm add <package-name>`    |
| 全局安装包         | `npm install -g <package-name>` | `pnpm add -g <package-name>` |
| 卸载包             | `npm uninstall <package-name>`  | `pnpm remove <package-name>` |
| 更新包             | `npm update <package-name>`     | `pnpm update <package-name>` |
| 运行脚本           | `npm run <script-name>`         | `pnpm run <script-name>`     |
| 初始化新项目       | `npm init`                      | `pnpm init`                  |
| 查看已安装的包     | `npm list`                      | `pnpm list`                  |
| 查看全局已安装的包 | `npm list -g`                   | `pnpm list -g`               |
| 查看包信息         | `npm info <package-name>`       | `pnpm info <package-name>`   |
| 搜索包             | `npm search <package-name>`     | `pnpm search <package-name>` |

## 硬链接和软连接 文件复制

需要先粗略的了解文件在计算机的存储形式，每个文件都独自占用一个 inode，文件内容由 inode 的记录来文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、文件的数据真正保存的 block 编号，想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块

![](/images/2024-08-01-15-15-17.png)

1. **传统复制文件** 当我们有一个文件A 将A 文件赋值出来叫B，此时如图所示，因此无论当我们改变 或者删除 A 或 B 任何一个都不会互相影响
![](/images/2024-08-01-15-16-26.png)

2. **硬链接（英语：hard link）** 是电脑文件系统中的多个文件平等地共享同一个文件存储单元,删除一个文件名字后，还可以用其它名字继续访问该文件，如图

![](/images/2024-08-01-15-28-25.png)

3. **符号链接（软链接soft link、Symbolic link）**，其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用，软链接的 inode 所指向的内容实际上是保存了一个绝对路径，当用户访问这个文件时，系统会自动将其替换成其所指的文件路径，删除源文件，软链接文件访问不了，删除软连接源文件依旧能访问

![](/images/2024-08-01-15-34-51.png)


### 计算机指令

文件的拷贝

~~~shell

window: copy foo.js foo_copy.js
macos : cp foo.js foo_copy.js
~~~

文件的硬链接
~~~shell
window: mklink /H aaa_hard.js aaa.js
macos : ln foo.js foo_hard.js
~~~~

文件的软连接

~~~shell
window: mklink aaa_soft.js aaa.js
macos : ln -s foo.js foo_copy.js
~~~

通过创建后的指令可以看出 硬软的具体区别:


1. **符号链接（Symbolic Link）：**
   - 使用 `mklink` 命令创建。
   - 可以跨不同的文件系统工作。
   - 可以指向文件或目录。
   - 删除符号链接不会影响原始文件或目录。
   - 需要管理员权限来创建。

示例命令：
```shell
mklink aaa_soft.js bbb.js
```

2. **硬链接（Hard Link）：**
   - 使用 `mklink /H` 命令创建。
   - 只能在同一文件系统内工作。
   - 只能指向文件，不能指向目录。
   - 删除硬链接会影响原始文件的链接数，只有当所有硬链接都被删除时，文件才会被真正删除。
   - 不需要管理员权限来创建。

示例命令：
```shell
mklink /H aaa_hard.js bbb.js
```

也就是 如果软连接删除了最初的文件 则所有创建的软连接全部失效，但硬链接不会且还不会占用磁盘空间


## pnpm 硬链接

pnpm 内部使用基于内容寻址的文件系统来存储磁盘上所有的文件，这个文件系统出色的地方在于:

不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 hardlink。

即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 hardlink，仅仅写入那一个新增的文件。

![](/images/2024-08-01-18-21-12.png)

![](/images/2024-08-02-16-29-09.png)

根据图片其实可以看出来会有一个 .pnpm 的文件，这文件中的都是硬链接链接到 pnpm 下载文件全局实际储存的位置这里就要具体细分

* 在pnpm7.0之前，统一的存储位置是~/.pnpm-score中的
* 在pnpm7.0之后，统一的存储位置进行了更改
  - 2.1. 在 Linux 上，默认是~/.local/share/pnpm/store
  - 2.2. 在 Windows 上： %LOCALAPPDATA%/pnpm/store
  - 2.3. 在 macOS 上： ~/Library/pnpm/store
- 
我们可以通过一些终端命令获取这个目录 `pnpm store path`

**pnpm store prune prune（修剪）：从store中删除当前未被引用的包来释放store的空间**

**将这些步骤可以总结**：

如果是使用 pnpm，依赖包将被存放在一个统一的位置

(1). 如果你对同一依赖包使用相同的版本，那么磁盘上只有这个依赖包的一份文件；

(2). 如果你对同一依赖包需要使用不同的版本，则仅有版本之间不同的文件会被存储起来；

(3). 所有文件都保存在硬盘上的统一的位置：

  * 当安装软件包时，其包含的所有文件都会硬链接到此位置，而不会占用额外的硬盘空间；

  * 这让你可以在项目之间方便地共享相同版本的依赖包；

现在再来看我们使用 pnpm 安装axios 好处 如果将本地的硬链接删除，本地软连接的包就不能使用，但删除本地硬链接的包并不会影响全局硬链接包，并且和npm 相比不能使用 axios 依赖包，例如以前axios 依赖z，我们可以直接在项目使用z，但现在只有真正安装的包会被软连接到node_modules, 和之前相比源码可以访问 本不属于当前项目所设定的依赖包 这种未知不知道后期依赖被删掉影响代码运行

## 重新理解pnpm 官网图

![](/images/2024-08-02-19-41-12.png)

1. 项目需要使用bar这个包(这个包内部需要依赖cat包)，在node_module的最外层会有一个bar@xxx， 他通过软连接到 .pnpm文件夹下的 bar@xxx/node_modules中的bar@xxx， 而这个bar通过硬连接到磁盘统一目录下存储的bar；  

2. bar@xxx/node_modules中的bar@xxx需要依赖foo@xxx，而这个foo@xxx通过软连接到 .pnpm根目录下的foo， 这个根目录下的foo又通过硬连接到磁盘统一目录下存储的foo




