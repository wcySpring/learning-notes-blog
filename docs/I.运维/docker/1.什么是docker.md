---
description: 什么是docker
---

在docker 之前传统的服务器通常只能运行一个操作系统和一组应用程序，这会导致硬件资源利用率低下。就诞生了虚拟化技术。利用虚拟化技术如图

- 现有一个物理服务器 8GB内存、i5 CPU、500GB磁盘
- 这一层表示在物理硬件上运行的主要操作系统，可能是Windows或macOS
- 虚拟机监视器位于主操作系统之上，负责创建和管理虚拟机，使得多个来宾操作系统可以在同一物理机器上独立运行。**CPU必须支持虚拟化，有时可能需要在主板的BIOS中启用此功能**。
- 多个运行在虚拟机监视器上的虚拟机。每个虚拟机都有其独立的来宾操作系统（Guest Operating System），可以是不同的操作系统，如CentOS、Ubuntu或macOS。
- 每个虚拟机中都运行着独立的应用程序，如Nginx、MySQL和Redis。虽然这些应用程序都在同一物理机器上运行，但由于它们分别在不同的虚拟机中，因此彼此之间是隔离的，互不干扰。
  
使得一台物理机器可以安装多个操作系统。每个操作系统可以独立运行其应用程序，从而使一台物理机器能够运行多个独立的应用程序

![](/images/2024-08-10-11-10-10.png)

虚拟化技术解决了以下几个关键问题：

1. **硬件资源利用率低的问题**：
   - 传统的服务器通常只能运行一个操作系统和一组应用程序，这会导致硬件资源利用率低下。例如，某些应用程序可能只使用了部分CPU或内存资源，而其他资源则闲置浪费。虚拟化通过在同一台物理服务器上运行多个虚拟机，能够最大化地利用硬件资源，提高整体的资源利用效率。

2. **应用程序隔离的问题**：
   - 在一台物理服务器上运行多个应用程序时，应用程序之间可能会发生冲突（如依赖不同版本的操作系统或库）。虚拟化通过为每个应用程序提供独立的虚拟机环境，确保每个应用程序都在独立的操作系统上运行，从而避免了应用程序之间的冲突和干扰。

3. **部署和管理的灵活性问题**：
   - 虚拟化技术使得部署新的服务器或应用程序变得更加快速和灵活。管理员可以通过虚拟化工具快速创建新的虚拟机，而无需购买新的硬件设备。这样，企业可以根据需求动态调整计算资源的分配，提升IT基础设施的响应速度和灵活性。

4. **降低硬件成本和管理成本的问题**：
   - 通过在一台物理服务器上运行多个虚拟机，企业可以减少对物理服务器的需求，从而降低硬件购买和维护的成本。此外，集中管理多个虚拟机比管理多个物理服务器更为简便，也减少了管理的复杂性和成本。

5. **提高系统可靠性和可用性**：
   - 虚拟化可以支持虚拟机的快速备份、迁移和恢复。当物理服务器出现故障时，虚拟机可以迅速迁移到另一台服务器上，减少停机时间，提高系统的可靠性和可用性。

在虚拟机中运行的指令会被翻译指令最后交给宿主机执行

**弊端** 每一个虚拟机都是一个完整的操作系统，要分配系统资源，虚拟机多到一定程度的时候，系统资源也会消耗殆尽，需要扩容

## 容器化
容器是一种轻量级的虚拟化技术，它的目的是创建“隔离环境”，类似于虚拟机，但实现方式更加简洁和高效。虚拟机通过虚拟化整个操作系统来实现资源隔离，每个虚拟机都有自己的完整操作系统副本，这使得虚拟机启动较慢、资源消耗较大。而容器采用的是进程级的系统隔离，这意味着容器共享主机操作系统的内核，不需要每个容器都有独立的操作系统。这样一来，容器能够更快地启动，并且占用更少的系统资源。

容器与虚拟机不同，它们共享主机操作系统的内核，但拥有自己的用户空间。这意味着所有容器运行在同一个操作系统内核上，因此它们不能像虚拟机那样运行与主机操作系统不同的操作系统。容器更加轻量，因为它们不需要完整的操作系统内核，而只是共享主机内核。（系统是容器自己的 内核使用的是运行系统的）

Docker 容器本质上仍然需要与宿主机共享相同的内核，因此在原理上，容器不能直接运行与宿主机不同的操作系统内核。也就是说，Linux 容器需要 Linux 内核，Windows 容器需要 Windows 内核。

Windows 上的 Docker：当你在 Windows 上安装 Docker Desktop 并运行 Linux 容器时，Docker Desktop 实际上是在 Windows 上创建了一个轻量级的虚拟机，这个虚拟机运行着一个 Linux 内核。这是通过 WSL 2（Windows Subsystem for Linux 2） 或 Hyper-V 实现的。因此才能window 上运行Linux 容器

Docker容器：使用Docker引擎进行调度和隔离，提高了资源利用率，在相同硬件能力下可以运行更多的容器实例；每个容器拥有自己的隔离化用户空间。

![](/images/2024-08-10-16-21-55.png)
## docker

docker 官网一句话介绍 Accelerate how you build, share, and run applications 翻译过来的就是 加速构建、分享和运行应用程序的过程，概括了docker 主要的三种行为，如下图

![](/images/2024-08-07-22-45-24.png)

这个图展示了 Docker 的工作流程，涉及三个主要组件：Client（客户端）、Docker Host（Docker 主机）和 Registry（镜像仓库）。以下是对图中各部分的总结：

### 1. Client（客户端）
客户端主要通过 `docker-cli` 命令行工具与 Docker 进行交互，包括以下操作：
- **docker pull redis**：从 Registry 拉取 Redis 镜像。
- **docker run redis**：运行拉取的 Redis 镜像，创建一个容器。
- **docker build xxx**：构建一个新的 Docker 镜像。
- **docker push xxx**：将构建好的镜像推送到 Registry。

### 2. Docker Host（Docker 主机）
Docker 主机是 Docker 守护进程（Daemon）所在的机器，负责管理容器和镜像：
- **Docker Daemon**：处理来自客户端的请求，管理容器的生命周期。
- **Containers（容器）**：运行的实例，如图中展示的多个容器实例。
- **Images（镜像）**：本地存储的镜像，例如 Redis 和 OpenJDK 镜像。

### 3. Registry（镜像仓库）
Registry 是存储和分发 Docker 镜像的地方，通常是 Docker Hub 或私有镜像仓库：
- **Images（镜像）**：存储各种应用镜像，如 MySQL、NGINX、Redis 和 OpenJDK 等。

### 工作流程
1. 客户端使用 `docker pull` 命令从 Registry 拉取镜像到 Docker Host。
2. Docker Host 上的 Docker Daemon 负责接收并存储镜像。
3. 客户端使用 `docker run` 命令从存储的镜像创建并运行容器。
4. 客户端可以使用 `docker build` 命令构建新的镜像，并通过 `docker push` 命令将其推送到 Registry 进行共享。

这个流程展示了 Docker 如何通过镜像和容器技术，简化应用的开发、部署和运行。

在 Docker 体系里，有四个对象 ( Object ) 是我们不得不进行介绍的，因为几乎所有 Docker 以及周边生态的功能，都是围绕着它们所展开的。它们分别是：镜像 ( Image )、容器 ( Container )、网络 ( Network )、数据卷 ( Volume )。

![](/images/2024-08-10-19-09-31.png)

## 镜像（Image）

Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

简单说镜像image其实就是一个文件系统，它与宿主机的内核一起为程序提供一个虚拟的linux环境。在启动docker container时，依据image，docker会为container构建出一个虚拟的linux环境。

## 容器( Container )

镜像是一个静态的模板，容器是基于这个模板运行起来的实例，容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全

每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。

- 镜像是只读的：镜像本身是不可变的。它像一个模子一样，永远保持不变。
- 容器是可变的：容器在运行时，可以读写文件、修改配置、运行各种命令等。容器的变化不会影响镜像本身。



![](/images/2024-08-10-19-08-34.png)