---
description: 原始类型的包装类
---

按照正常理解来说**原始类型并非对象类型**，所以从理论上来说，它们是**没有办法获取属性或者调用方法**

下面案例name 是一个字符串类型，但是可以像对象一样使用调用length 方法
~~~js
var  name = "Hello World"
console.log(name.length)
~~~

是因为JavaScript为了可以使其可以获取属性和调用方法，对其封装了对应的包装类型，常见的包装类型有：String、Number、Boolean、Symbol、BigInt类型

## 装箱转换

每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象


抛开symbol 看其他类型的装箱转换
~~~js
// Number
1
new Number(1)

// String
'aaa'
new String('aaa')

// Boolean
true
new Boolean(true)
~~~
**特殊的Symbol** 由于Symbol 类型是不支持new 来调用的，因此转换我们可以使用一个call来帮助 `var symbolObject = (function(){ return this; }).call(Symbol("a"));`

~~~js
console.log(typeof symbolObject); //object
console.log(symbolObject instanceof Symbol); //true
console.log(symbolObject.constructor == Symbol); //true

~~~

当调用一个原始类型的属性或者方法时，会进行如下操作:

1. 根据原始值，创建一个原始类型对应的包装类型对象
2. 调用对应的属性或者方法，返回一个新的值
3. 创建的包装类对象被销毁
~~~js
// var name = "Hello World"
// console.log(name.length)
var name = new String("Hello World")
console.log(name.length)
~~~
注：JavaScript引擎会进行很多的优化，它可以跳过创建包装类的过程在内部直接完成属性的获取或者方法的调用，null、undefined没有任何的方法，也没有对应的“对象包装类


