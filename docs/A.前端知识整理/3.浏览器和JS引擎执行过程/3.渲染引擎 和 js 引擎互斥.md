---
description: 了解渲染引擎 和 js 引擎互斥
  -  浏览器代码执行过程
---


当网页的界面需要重绘（Repaint）或者某个操作导致页面布局发生变化（回流，Reflow）时，GUI渲染线程会被触发执行。重绘是指更新页面中的某个元素的外观，而回流是指重新计算页面布局，可能涉及到多个元素的位置和尺寸变化。

然而，需要注意的是，GUI渲染线程与JavaScript引擎是互斥的。这意味着当JavaScript引擎正在执行代码时，GUI渲染线程会被挂起，无法执行。这样做是为了避免JavaScript代码与页面渲染之间的冲突。在JavaScript引擎执行期间，所有的GUI更新操作会被保存在一个队列中。当JavaScript引擎执行完毕并空闲下来时，队列中的GUI更新操作会立即被执行，以确保页面渲染的正确性。

![图 7](/images/720c531563ca21edc34431cb8922a445f607f0740324a5db68811011bd24830a.png)  

两个JavaScript方法（updateSync和updateAsync）在执行时的不同表现。当运行updateSync方法时，页面上的按钮会立刻显示999，而运行updateAsync方法时，按钮上的数字会逐渐增加。

这种现象可以通过JavaScript引擎线程和GUI渲染线程之间的互斥关系来解释。在updateSync方法执行过程中，GUI渲染线程会等待JavaScript引擎线程执行完毕，因此按钮上的数字会直接变成999。而在updateAsync方法执行过程中，GUI渲染线程可以在JavaScript引擎线程执行过程中更新按钮上的数字，因此按钮上的数字会逐渐增加。这种差异可以通过图像更直观地展示。

~~~js
<div id="output"></div>

<button onclick="updateSync ()">Run Sync</button>

<button onclick="updateAsync ()">Run Async</button>

<script>

function updateSync() {
    for (var i = 0; i < 1000; i++) {
        document.getElementById('output').innerHTML = i;
    }
}

function updateAsync() {
    var i = 0;

    function updateLater() {
        document.getElementById('output').innerHTML = (i++);
        if (i < 1000) {
            setTimeout(updateLater, 0);
        }
    }

    updateLater();
}
</script>

~~~

### js 阻塞 和渲染引擎组合后的渲染全过程

因此实际浏览器渲染过程其实是
这段内容描述了浏览器渲染页面的整个过程：

1. DOM Tree：浏览器解析HTML文档，生成DOM树。当DOM树构建完成时，触发DOMContentLoaded事件。

2. 执行JS：在DOM树构建过程中，如果遇到JavaScript代码，浏览器会执行这些代码。在执行过程中，可能会对DOM树进行修改。注意，JS执行会阻止接下来的渲染过程，直到JS执行完成。

3. CSSOM Tree：浏览器解析CSS样式，生成CSSOM树。

4. Render Tree：根据DOM树和CSSOM树，生成渲染树。渲染树是浏览器将来按照这个树来绘制页面的依据。

5. Layout：计算渲染树中每个元素的布局信息，如位置、大小等。这个过程也称为回流或重排。

6. Painting：根据渲染树和布局信息，绘制页面。这个过程也称为重绘。在绘制过程中，浏览器采用分层绘制的策略，将页面分为多个图层，分别进行绘制。




### 为什么加载script 会阻止dom
当HTML解析器遇到`<script>`标签时，它会暂停对HTML文档的解析，然后加载、解析并执行其中的JavaScript代码。这是因为JavaScript可以通过诸如`document.write()`等方法来修改DOM结构，从而改变文档的形状。为了确保正确处理这些更改，HTML解析器需要等待JavaScript代码执行完成后，才能继续解析HTML文档。


### 为什么不要将 script 标签放到头部
1. `<head>`中放置的`<script>`元素会阻塞页面的渲染过程因为上面说过,当 JS 引擎执行时，GUI 线程会被挂起。因此把 JavaScript 放在`<head>`里，意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面。**对应问题**：外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，用户体验会变得很糟糕

2. 将 JavaScript 脚本放在`<body>`的最后面。这样可以避免资源阻塞，页面得以迅速展示

3. 也可使用 defer/async 做标记

## 关于defer/async
遇到 `<script src='xxx/xxx.js'>`，会阻碍GUI的渲染, 因此 增加了两个属性 defer/async ，了解之前需要知道一个概念，script 这里需要两部分来看，第一部分是 **下载**，第二部分是 **执行**，一个文件的**下载过程不会阻止其他文件的下载和执行**，但一个文件的**执行过程会阻止其他文件的执行（js 和 渲染引擎互斥）**，而不会阻止其他文件的下载。下载过程 也分为同步和异步，同步只能下载完一个文件才能下载另一个，异步加载允许浏览器同时下载多个文件以及执行， 但是中间要注意但是无论下载时什么方式，但是文件执行只能一次一个

因此，为了优化这个过程，可以将下载和执行问题拆解，从而实现更高效的加载和执行。关键在于合理安排何时触发执行，以充分利用浏览器的资源。

先通过案例在 `script` 引入 `index.js`  其中 `index.js` 是一个从10000打印到0的一个方法，下面是四种不同形式的使用,案例说明**当你在你本地想查看同等案例的时候需要一次仅放开一种情况来查看效果**，四种情况效果
1. 第一种情况 script 放置顶部，运行后 `<p>我在开始渲染</p>` 没有立刻渲染
2. 第二种情况 script 增加了'defer'属性，运行后 `<p>我在开始渲染</p>` 立刻渲染
3. 第三种情况 script 增加了'async'属性，运行后 `<p>我在开始渲染</p>` 立刻渲染
4. 第四种情况 script 放到底部，运行后 `<p>我在开始渲染</p>` 立刻渲染


~~~html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 第一种 -->
    <script  src="index.js"></script> 
    <!-- 第二种 -->
    <script defer src="index.js"></script>
    <!-- 第三种 -->
    <script async src="index.js"></script>
</head>
<body>
    <p>我在开始渲染</p>
    <!-- 第四种 -->
    <script  src="index.js"></script>
</body>
</html>
~~~
* index.js
~~~js
let count = 10000
while (count) {
    count -= 1
    console.log(count);
}
~~~

上面面过程中第一种 和 第四种情况他们都是 下载和执行 全部阻碍html渲染,并且浏览器一次只能执行一个文件，这导致了JS 引擎执行时，GUI 线程会被挂起，遇到'script' 下载对应资源，下载后解析资源，在重新渲染html，但由于第一种和第四种位置放置区别，产生了两种不同效果，它效果如图
![图 8](/images/7fae0d1874069911fa3e908ce4f655e2e7e037703a168ca3c4d21445633f1ba4.png)  

关于第二种和第三种需要具体来看

### Async -- 异步

![图 11](/images/35e37c8fd10807a1cf66bab0f5a03f4d6376efc24fa8cbfb7c04a113a5680f96.png)  


1. `async`属性允许浏览器在执行其他操作的同时并行下载指定的JavaScript资源。这意味着在下载JS文件时，浏览器不会阻塞其他操作，提高了页面加载的效率。但是，一旦JS文件下载完成，浏览器将立即执行它，这可能会阻止HTML文件的当前渲染。

2. 使用`async`属性加载的脚本执行顺序是不可预测的。例如，如果有三个脚本分别将一个数字记录到控制台中，使用`async`加载时，它们的执行顺序可能会发生变化，导致输出的数字顺序不确定。

![图 12](/images/e409c01971c82f864ee0d5be5c278f5c692ecd602c076c701145bdddd483bbff.png)  


3. `async`属性不能保证脚本在`DOMContentLoaded`事件之前或之后执行。这意味着，当使用`async`加载脚本时，我们无法确保脚本在页面的某个特定时刻执行，可能会导致一些依赖于特定执行时机的问题。

* 如果脚本在DOMContentLoaded之前执行，那么它可能无法访问或操作尚未加载和解析的页面元素，从而导致脚本执行失败或出现错误。

* 如果脚本在DOMContentLoaded之后执行，那么它可能会错过一些关键的初始化操作，导致页面功能不完整或出现异常。

### defer-- 延迟

![图 10](/images/d060be87361581df12d3d37a713f705c9253f39ba7db37646ca1832424be49d2.png)  


1. 当在JS文件中使用defer属性时，浏览器会与其他文件一起下载这个JS文件，但是不会立即执行它。相反，它会等到HTML文件完全呈现后才开始执行。这与async属性不同，后者会在资源下载完成后立即执行。使用defer属性的好处是，它不会阻塞页面的渲染过程。

2. 使用defer属性的多个JS文件将按照它们在HTML文件中的顺序依次加载和执行。这保证了脚本之间的依赖关系得到正确处理。

3. defer属性使得JS文件在DOM树构建完成后、DOMContentLoaded事件触发之前执行。这意味着，当脚本开始执行时，页面的DOM结构已经完全加载，可以被脚本安全地访问和操作。

![图 9](/images/322322830216233dc627685beeccf57cee11e32fee8728a24e872254ba0a697f.png)  

~~~html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="./js/test.js" defer></script>
  <script src="./js/demo.js" defer></script>
</head>
<body>
  
  <div id="app">app</div>
  <div class="box"></div>
  <div id="title">title</div>
  <div id="nav">nav</div>
  <div id="product">product</div>

  <!-- 1.下载需要很长的事件, 并且执行也需要很长的时间 -->
  <!-- 总结一: 加上defer之后, js文件的下载和执行, 不会影响后面的DOM Tree的构建 -->
  <script>
    // 总结三: defer代码是在DOMContentLoaded事件发出之前执行
    window.addEventListener("DOMContentLoaded", () => {
      console.log("DOMContentLoaded")
    })
  </script>
  
  <h1>哈哈哈哈啊</h1>

</body>
</html>
~~~

### 总结

1. **defer** 和link是类似的机制了，不会阻碍GUI渲染，当GUI渲染完，才会把请求回来的JS去渲染
2. **async** 请求JS资源是异步的「单独开辟HTTP去请求」，此时GUI继续渲染；但是一但当JS请求回来，会立即暂停GUI的处理，接下来去渲染JS
3. 加入我们有5个JS的请求，如果不设置任何属性，肯定是按照顺序请求和渲染JS的「依赖关系是有效的」；但是如果设置async，谁先请求回来就先渲染谁，依赖关系是无效的；如果使用defer是可以建立依赖关系的(浏览器内部在GUI渲染完成后，等待所有设置defer的资源都请求回来，再按照编写的依赖顺序去加载渲染js)；
4. 真实项目开发，我们一般把link放在页面的头部「是为了在没有渲染DOM的时候，就通知HTTP去请求CSS了，这样DOM渲染玩，CSS也差不多回来了，更有效的利用时间，提高页面的渲染速度」；我们一般把JS放在页面的底部，防止其阻碍GUI的渲染，如果不放在底部，我们最好设置上async/defer；



## 还需要了解 这部分必看
[DOMContentLoaded与load的区别](https://www.cnblogs.com/caizhenbo/p/6679478.html)


## 参考
[Async vs Defer vs Preload vs Server Push](https://webspeedtools.com/async-vs-defer-vs-preload-vs-server-push/#Async)

[How and when to use Async and Defer attributes](https://zellwk.com/blog/javascript-async-and-defer/)

[更快地构建DOM: 使用预解析, async, defer 以及 preload](https://www.w3cplus.com/javascript/building-the-dom-faster-speculative-parsing-async-defer-and-preload.html)