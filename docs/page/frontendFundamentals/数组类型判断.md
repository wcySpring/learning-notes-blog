>[success] # 数组类型判断
~~~
var a = [];
// 1.基于instanceof
a instanceof Array;
// 2.基于constructor
a.constructor === Array;
// 3.isPrototypeOf() 方法允许你检查一个对象是否存在于另一个对象的原型链上。
Array.prototype.isPrototypeOf(a);
// 4.基于getPrototypeOf
Object.getPrototypeOf(a) === Array.prototype;
// 5.基于Object.prototype.toString 这是最推荐的形式
Object.prototype.toString.apply(a) === '[object Array]';
~~~
>[danger] ##### 关于isPrototypeOf 和 instance of
~~~
1.通过下面例子可以看出，'instance of' 和 'isPrototype' 都可以对深层次检测，即在原型链上不停找是否有
相同的
2.从'Mdn' 定义来看`isPrototypeOf()`与`instanceof`运算符不同。在表达式 "`object instanceof AFunction`"中，
`object`的原型链是针对`AFunction.prototype`进行检查的，而不是针对`AFunction`本身。
3.通过上面定义和下面案例可以看出 当想通过查找关系从属的时候。'instanceof' 默认帮助我们从'prototype'
去对比关系，但是'isPrototypeOf' 如果你没有指定'prototype'话查出结果 是针对当前对象本身导致结果为false
~~~
~~~
class B {}
class A extends B {}

const a = new A()
console.log(a instanceof A) // true
console.log(A.prototype.isPrototypeOf(a)) // true
console.log(A.isPrototypeOf(a)) // false
~~~
>[danger] ##### es6 isArray
~~~
1. Array.isArray 判断是不是数组 其实他polyfill
if (!Array.isArray){
  Array.isArray = function(arg){
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
~~~