>[success] # 引用父对象
~~~
1.在特定情况下需要删除子节点的内容，刚才的案例将'枝'和'叶'再度细分，
让'叶'不能在添加，所有数据内容都存在我们在'枝'中定义的数组，这样对
我们操作'叶子'必须要找到他的枝干才行，因此需要'保存的时候要引用父对象'
2.书中的解释是'能需要让请求从子节点往父节点上冒泡传递。'
~~~
>[danger] ##### 代码案例
~~~
1.当删除的时候 this.parent 存的是父对象因此直接调用
2.判断存储的对象是否是当前实例 来决定是否删除
3.储存内容可以倒着存
~~~
~~~
// Folder 文件
var Folder = function (name) {
    this.name = name
    this.parent = null
    this.files = []
};
// 给添加的对象增加父节点的指向
Folder.prototype.add = function (file) {
    file.parent = this
    this.files.push(file)
};
Folder.prototype.scan = function(){
    console.log( '开始扫描文件夹: ' + this.name );
    for ( var i = 0, file, files = this.files; file = files[ i++ ]; ){
        file.scan();
    }
};
// 当删除的时候 this.parent 存的是父对象因此直接调用
// 判断存储的对象是否是当前实例 来决定是否删除
Folder.prototype.remove = function(){
    if ( !this.parent ){ //根节点或者树外的游离节点
        return;
    }
    for ( var files = this.parent.files, l = files.length - 1; l >=0; l-- ){
        var file = files[ l ];
        if ( file === this ){
            files.splice( l, 1 );
        }
    }
};
// 文件 --------------------------
var File = function( name ){
    this.name = name;
    this.parent = null;
};
File.prototype.add = function(){
    throw new Error( '不能添加在文件下面' );
};
File.prototype.scan = function(){
    console.log( '开始扫描文件: ' + this.name );
};
File.prototype.remove = function(){
    if ( !this.parent ){ //根节点或者树外的游离节点
        return;
    }
    for ( var files = this.parent.files, l = files.length - 1; l >=0; l-- ){
        var file = files[ l ];
        if ( file === this ){
            files.splice( l, 1 );
        }
    }
};
// ------------------ 调用 ---------------
var folder = new Folder( '学习资料' );
var folder1 = new Folder( 'JavaScript' );
var file1 = new Folder ( '深入浅出 Node.js' );
folder1.add( new File( 'JavaScript 设计模式与开发实践' ) );
folder.add( folder1 );
folder.add( file1 );
folder1.remove(); //移除文件夹
folder.scan();
~~~