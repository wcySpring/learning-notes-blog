>[success] # 柯里化封装
* 经常可以看到函数封装时候都有类似写法
 **curryFn.apply(this, args.concat(newArgs))** 既然已经函数调用了为什么还要指派**apply** this指向？ 原因是当调用函数时候有可能使用者利用了**apply** 等改变指向例如调用时候**fooCurry.apply({ a: 11 }, [10])(20)(30)**
~~~
    // 手动转化
	function foo(x, y, z) {
      console.log(x + y + z)
    }
    // 封装函数: 自动转化柯里化过程(有一点难度)
    function hyCurrying(fn) {
      function curryFn(...args) {
        // 两类操作:
        // 第一类操作: 继续返回一个新的函数, 继续接受参数
        // 第二类操作: 直接执行fn的函数
        if (args.length >= fn.length) { // 执行第二类
          // return fn(...args)
          return fn.apply(this, args)
        } else { // 执行第一类
          return function(...newArgs) {
            // return curryFn(...args.concat(newArgs))
            return curryFn.apply(this, args.concat(newArgs))
          }
        }
      }

      return curryFn
    }

    // 对其他的函数进行柯里化
    var fooCurry = hyCurrying(foo)
    fooCurry(10)(20)(30)
    fooCurry(55, 12, 56)
~~~