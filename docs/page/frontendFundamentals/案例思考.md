>[danger] ##### 案例思考1
~~~
1.下面代码执行打印的结果为 
  ƒ a(){} 
  1
 原因是，首先区分'声明发生在编译期'，'语句发生在运行期'之前说过var 声明的变量会变量提升，但是仅仅只是
变量声明的提升，并不是变量定义，fucntion 在非块作用域的情况下他将会发生声明加定义，因此第一打印因为
var 仅仅是声明了变量a 但function a 更明确的给这个声明进行了值的定义因此打印function，代码向下执行过程
遇到 a=1 此时重新给a 赋值为1，当在执行到function a 的时候因为在最初时候function已经 经历了定义赋值的阶段
此时并不会重新给function a 赋值，因此当执行到下一次打印时候结果为 1
~~~
~~~
console.log(a)
var a = 1
function a(){}
console.log(a)
~~~
>[danger] ##### 案例思考2
~~~
1.下面代码执行打印的结果为 
    ƒ a() {}
    2
    1
 主要分析function fn ，首先fn 会有自己的AO 即上下文变量存储地方，最开始形参赋值实参 AO中的 a --1
 但是function 内部开始发生变量提升此时 函数内部的var a  变量提升只是声明，此时a在实参已经声明过了，
 其实变相无效，注意变量提升仅仅是声明 并不会赋值因此并不会吧实参中a 的值赋值给undefined，当到了
 function a 此时经历声明加赋值，虽然a已经被声明过了 但是却又被重新赋值因此 函数内部的第一个打印
 为function，当依次执行 a =2 将a重新赋值，所以下一次打印为2，函数内部存在作用域的，因此最后打印
 结果为1
/!*
 * EC(G)
 *    a  --> 1
 *    fn --> 0x000  [[scope]]:EC(G)
 * 变量提升:
 *   var a;   
 *   function fn(a) {...};
 *!/
var a = 1;
function fn(a) {
    /!*
     * EC(FN)
     *   a --> 1
     *     --> 0x001 [[scope]]:EC(FN)
     *     --> 2
     * 作用域链:<EC(FN),EC(G)>
     * 形参赋值:a=1
     * 变量提升:
     *   var a;
     *   function a() {};
     *!/
    console.log(a); //=>函数
    var a = 2;
    function a() {}
    console.log(a); //=>2
}
fn(a); //fn(1)
console.log(a); //=>1 
~~~
~~~
var a = 1;
function fn(a) {
    console.log(a); //=>函数
    var a = 2;
    function a() {}
    console.log(a); //=>2
}
fn(a); 
console.log(a); 
~~~
>[danger] ##### 案例三
~~~
1.当函数在块级作用域时候，此时function 将在全局作用域变量提升的时候只是声明并不会定义，当执行到块级
时候，在块级里面提升是声明加定义，并且全局会复制一份块的function 定义
~~~
~~~
console.log(foo); //undefined 只声明为定义
{
    console.log(foo); //函数 在块级时候声明加定义 并且复制一份给了全局
    function foo() {}
    console.log(foo); //函数 
    foo = 1;
    console.log(foo); //1 重新赋值
}
console.log(foo); //函数  全局是复制的块级里面的更改并不影响全局的
~~~