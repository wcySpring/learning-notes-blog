>[success] # 惰性载入函数
~~~
1.下面利用闭包let getCss = functio(){}  第一次执行时候做好了属性兼容的判断，此时 getCss = function 
将let 定义的函数重新赋值并且保留作用域，可以看闭包章节具体解释，可以参考下面小闭包案例来理解下面
整个大案例
function a() {
    let x = 1
    a = function () {
        x += 1
        console.log(x)
    }
}

a() // 当a执行完后内部定义a = function(){} 因为没有let const var 等声明此时a已经定义在全局
a() // 2 重新定义的a 内部x 引用上级作用域即之前a中let x= 1 内存因为被新的a=function 占用未被释放
a() // 3 因此也形成闭包

在做一些一次性质即可时使用这种案例思想
~~~
~~~
//   + getComputedStyle([Element])[ATTR]  获取当前元素所有经过浏览器计算的样式
//   + [Element].currentStyle[ATTR]  IE6~8

// 弊端：第一次执行，需要校验一下兼容性；但是后续每一次执行，都需要重新校验 “这个操作是多余的”...
/* let getCss = function getCss(ele, attr) {
    if ('getComputedStyle' in window) {
        return window.getComputedStyle(ele)[attr];
    }
    return ele.currentStyle[attr];
};
console.log(getCss(box, 'width'));
console.log(getCss(box, 'padding'));
console.log(getCss(box, 'display')); */

let getCss = function (ele, attr) {
    if ('getComputedStyle' in window) {
        getCss = function (ele, attr) {
            return window.getComputedStyle(ele)[attr];
        };
    } else {
        getCss = function (ele, attr) {
            return ele.currentStyle[attr];
        };
    }
    return getCss(ele, attr);
};
console.log(getCss(box, 'width'));
console.log(getCss(box, 'padding'));
console.log(getCss(box, 'display'));
~~~
[惰性函数载入参考 ](http://www.zhangyunling.com/375.html)