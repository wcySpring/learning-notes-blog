[TOC]
>[success] # 享元模式的适用场景
* 书中对着一部的总结
~~~
1.使用了享元模式之后，我们需要分别多维护一个 factory 对象和一个 manager 对
象，在大部分不必要使用享元模式的环境下，这些开销是可以避免的。
2.享元模式使用场景：
    2.1.一个程序中使用了大量的相似对象。
    2.2.由于使用了大量对象，造成很大的内存开销。
    2.3.对象的大多数状态都可以变为外部状态。
    2.4.剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。
~~~
>[success] # 享元模式对内外部状态的依赖
~~~
1.实现享元模式的关键是把内部状态和外部状态分离开来。有多少种内部状态的组合，
系统中便最多存在多少个共享对象
2.外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象
~~~
 >[danger] ##### 没有内部状态的享元
~~~
1.当没有内部状态的享元，就说明所有实例都共享同一个对象，只需要改变的就是用来缓存的
工厂方法和改变创建内部共享的实例
~~~
* 以上一章节的案例没有共享的内部状态的类可以定义成
~~~
var Upload = function(){}; 
~~~
* 工厂函数不需要在缓存了定义成
~~~
var UploadFactory = (function(){
    var uploadObj;
    return {
        create: function(){
            if ( uploadObj ){
                return uploadObj;
            }
            return uploadObj = new Upload();
        }
    }
})();
~~~
>[danger] ##### 没有外部
~~~
1.如果没有外部状态的分离，即使使用了共享的技术，但并不是一个纯粹的享元模式
~~~