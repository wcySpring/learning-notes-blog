[TOC]
>[success] # 获取两数组中交集
~~~
1.获取交集，即过滤出两个数组中相同项，也就是A数组某一项是否在B数组中的某一项
~~~
>[info] ## 解决思路
~~~
1.使用filter 和 some配合，A过滤出来的某个元素是否在B中存在存在则作为filter过滤条件
2.使用filter 和 set 配合，A中的元素是否 has 在B中set 元素
3.使用filter 和 findIndex 配合 A中过滤的元素是否B中
~~~
>[danger] ##### filter 和 set 配合
~~~
// 交集单项
const intersection =(a,b)=>{
    const setA = new Set(a)
    const setB = new Set(b) 
    return [...setA].filter(val=>setB.has(val))
}
console.log(intersection([1, 2, 3], [4, 3, 2])) // [2, 3]
// 交集对象
const intersectionBy = (a, b, fn) => {
    const s = new Set(b.map(fn));
    return [...new Set(a)].filter(x => s.has(fn(x)));
  };
  console.log(  intersectionBy(
    [{ title: 'Apple' }, { title: 'Orange' }],
    [{ title: 'Orange' }, { title: 'Melon' }],
    x => x.title
  )) // [ { title: 'Orange' } ]
~~~
>[danger] ##### some 和 filter 
~~~
const intersectionWith = (a, b, comp) =>
  a.filter(x => b.some(y => comp(x, y)));
console.log(intersectionWith(
    [1, 1.2, 1.5, 3, 0],
    [1.9, 3, 0, 3.9],
    (a, b) => Math.round(a) === Math.round(b)
  )) // [2, 3]

~~~
>[danger] ##### filter 和 findIndex 配合
~~~
const intersectionWith = (a, b, comp) =>
 a.filter(x => b.findIndex(y => comp(x, y)) !== -1);
console.log(intersectionWith([1, 2, 3], [4, 3, 2],(a,b)=>a===b)) // [2, 3]
~~~
>[info] ## 只返回true 和 false 不返回具体内容做两数组是否有交集
~~~
1.如果上面交集结果为空，可以理解为两个数组没有任何交集则互相都不包含彼此元素，
现在不用具体元素只需要返回true 或者false，every 方法恰好满足返回true or false
2.利用some 和 来实现
~~~
>[danger] ##### 没有交集返回true 有交集返回false
~~~
const isDisjoint  = (a,b)=>{
    // a 中的元素是否在b 中
    const sA = new Set(a)
    const sB = new Set(b)
    return [...sA].every(val=>!sB.has(val))
}
 
const a = [1,2]
const b = [3,4]
// a 和 b 是否没交集
let flag = isDisjoint(a,b) // true
console.log(flag)
~~~
>[danger] ##### 利用some 和 来实现
~~~
const {log} =console

const includesAny = (arr, values) => values.some(v => arr.includes(v))

log(includesAny([1,2,3,4],[2,9])) // true
log(includesAny([1,2,3,4],[8,9])) // false
~~~
