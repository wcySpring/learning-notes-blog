>[success] # a.x = a ={n:2} 
* 文章参考来自极客时间周爱民老师《JavaScript核心原理解析》
~~~
1.首先要弄清一个问就是，var/let/const 这些声明的操作符，语句中的等号左边，绝不可能是一个'表达式'，
也就是绝对不可以是一个'引用'例如：
    var a.x = ...   // <- 这里将导致语法出错
~~~
>[info] ## 三个案例来说明

>[danger] ##### 案例一  
~~~
1. 首先案例一中先执行了c.a 因为这是一个表达式，然后紧接着执行了b这个表达式，然后执行了{'a':1},接着从右往左一
次赋值就得到案例一的结果
~~~
~~~
var c = {};
var b= {}
c.a = b = {'a':1};
console.log(c.a); // {a: 1}
~~~
>[danger] ##### 案例二
~~~
1.案例二也是一样先执行表达式d.a ，然后依次 d ，{'a':1},然后又依次从右往左赋值，但是d先变成了  
{'a':1},此时d的指向已经变了不是之前的指向了，然后该给d.a赋值，但是d.a在表达式执行赋值其实是d是上一次，
但由于打印d.a 其实是现在的d.a 因此得到的是1
~~~
~~~
var d = {};
d.a = d = {'a':1};
console.log(d.a); // 1
~~~
>[danger] ##### 案例三
~~~
1.依次执行e.a，e，{'ee':1}然后又从右往左赋值，又到了e.a的时候发现e的指向已经变了，原来的e还是在的，
在这个赋值操作中它也成功赋值了，只是赋在'原来的e'，但是下面打印的e.a其实新的指向也就是{'ee':1},因为这里确实
没有'a'这个key 所以打印就是undefined
~~~
~~~
var e = {};
e.a = e = {'ee':1};
console.log(e.a); // undefined
~~~
* 如何证明上面说的原来的e还在
~~~
// ref 保存的是上一次的a
var a = {n:1}, ref = a;
a.x = a = {n:2};
console.log(a.x); // --> undefined
console.log(ref.x); // {n:2}
~~~
