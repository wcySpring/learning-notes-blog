[TOC]
>[success] # 数组去重
~~~
1.去重用更直白的话翻译'过滤出新数组每一项都是唯一' 或者"记录保存第一次出现的位置",这个思路下具备的方法有
  1.1.利用双重for循环 遍历数组中的每一项，将当前项与后一项相比较（除去最后一项），遇到相同
  的就删除，便返回了一个没有重复的数组
  1.2.利用for循环 配合数组'includes' 或'indexOf'方法去重和'reduce' 解决思路类似
  1.3.通过'filter ' 方法配合'indexOf' 特性获取当前值在数组中第一次出现的位置和当前位置比较
2.找到一种'数据结构',其结构要具备只能是唯一不能重复
   2.1.利用对象属性不能重复的特性去去重，利用对象唯一key 的特性 利用对象做key 问题是如果数字和字符串相同
   key最后都转换成字符串导致出现bug
   2.2.解决办法使用Map 来解决
3.利用数组的sort方法先排序在去重（相邻元素对比法）
4.利用现成的api 'Set' 来解决问题
~~~
* 小说明
~~~
1.findIndex对象key查找的时候如果key不存在相当于undefined和undefined 比较 返回第一项会产生歧义

let arr1 = [ {key:'1',name:'q'},{key:'2',name:'q'},{key:'1',name:'a'} ]
console.log( arr1.findIndex(val=>val.id === undefined)); // 0
~~~
>[danger] ##### 双层for循环
~~~

const arr = ['123',564,'123', '564', 'haoha', '1', '1', '1']

const unique = (ls) =>{
    for(let i=0;i<ls.length;i++){
        let item = ls[i]
        for(let j=i+1;j<ls.length;j++){
            if(item===ls[j]) {
                console.log(item);
                ls.splice(j,1)
                j-- // 数组少一位循环相对减少
            }
        }
    }
    return ls
}
console.log(unique(arr))
~~~
>[danger] ##### filter 和 index 配合
~~~
const arr = ['123',564,'123', '564', 'haoha', '1', '1', '1']
// indexOf 版本
const unique = (ls)=>ls.filter ((val,index)=>{
    return (ls.indexOf(val)===index) 
})
console.log(unique(arr));




//  数组对象使用findIndex
let arr1 = [ {key:'1',name:'q'},{key:'2',name:'q'},{key:'1',name:'a'} ]

const unique2 =(ls,fn)=> ls.filter((value,index)=>{
    return ls.findIndex(val=>fn(val,value))===index
    
})
console.log(unique2(arr1,(val,curr)=>val.key===curr.key))
~~~
>[danger] ##### reduce 和index 配合'indexOf'
~~~
const arr = ['123',564,'123', '564', 'haoha', '1', '1', '1']
// includes 版本
const unique = (ls)=>ls.reduce((acc,curr)=>{
    if(!acc.includes(curr)) acc.push(curr)
    return acc
},[])
console.log(unique(arr));

// indexof 版本
const unique1 = (ls)=>ls.reduce((acc,curr,index)=>{
    if(ls.indexOf(curr)===index)acc.push(curr)
    return acc
},[])

console.log(unique1(arr));


//  数组对象使用findIndex
let arr1 = [ {key:'1',name:'q'},{key:'2',name:'q'},{key:'1',name:'a'} ]

const unique2 =(ls,fn)=> ls.reduce((acc,curr,index)=>{
    if(ls.findIndex(val=>fn(val,curr))===index)acc.push(curr)
    return acc
},[])
console.log(unique2(arr1,(val,curr)=>val.key===curr.key))
~~~
>[danger] ##### 利用对象做第三方中介
~~~
// 利用对象唯一key 的特性 利用对象做key 问题是如果数字和字符串相同最后key是字符串出错如下
const arr = ['123',564,'123', '564', 'haoha', '1', '1', '1']
const unique = (ls)=>Object.keys(ls.reduce((acc,curr)=>{
    if(!(curr in acc)) acc[curr] = curr
    return acc
},{}))
console.log(unique(arr)); // [ '1', '123', '564', 'haoha' ]

// 利用对象唯一key 的特性 使用map 来解决
const arr = ['123',564,'123', '564', 'haoha', '1', '1', '1']

const unique = (ls)=>{   
    const map = ls.reduce((acc,curr)=>{
            if(!acc.has(curr)) acc.set(curr,curr); 
            return acc
        },new Map()).values()
    return [...map]
}
console.log(unique(arr)); // [ '123', 564, '564', 'haoha', '1' ]


// map 对象形式
let arr1 = [ {key:'1',name:'q'},{key:'2',name:'q'},{key:'1',name:'a'} ]

const unique2 =(ls,key)=>{ 
    const map = ls.reduce((acc,curr)=>{
    if(!acc.has(curr[key])) acc.set(curr[key],curr)
        return acc
    },new Map()).values()
    return [...map]
}
console.log(unique2(arr1,'key'))
~~~
>[danger] ##### 利用sort排序在和相邻元素比较
~~~
function uniq(array){
    array.sort();
    var temp=[array[0]];
    for(var i = 1; i < array.length; i++){
        // 当值和存入值最后一项是否相等相等则重复
        if( array[i] !== temp[temp.length-1]){
            temp.push(array[i]);
        }
    }
    return temp;
}

var aa = [1,2,"2",4,9,"a","a",2,3,5,6,5];
console.log(uniq(aa));

~~~
>[danger] ##### 利用set
~~~
var aa = [1,2,"2",4,9,"a","a",2,3,5,6,5];
console.log([...new Set(aa)]);
~~~