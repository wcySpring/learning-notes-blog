[TOC]
>[success] # 获取数组中不重复的元素
~~~
1.'获取数组中不重复的元素'也就是过滤出的每一项在当前数组中有且只有一个
~~~
>[info] ## 解决思路
~~~
1.使用'fitler'和'indexOf'配合'lastIndexOf' 保证当前元素首尾查都是位置相同的
2.使用'fitler' 和'every' 配合来查询,利用every 我本身和我本身的值相等外，其他跟我不是本身的值相等就有重复
3.使用对象作为统计获取统计唯一值
4.'filter'和'filter' 嵌套使用
~~~
>[danger] #####  'fitler'和'indexOf'配合'lastIndexOf' 
~~~
const {log} =console

const filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));
log(filterNonUnique([1, 2, 2, 3, 4, 4, 5])) // [ 1, 3, 5 ]
~~~
>[danger] ##### 'fitler' 和'every' 配合
~~~
// arr.every((x, j) => (i === j) === fn(v, x, i, j))) 把这一部分看作我本身和我本身的值相等外，其他跟我不是本
// 身的值相等就有重复
// true 返回给filter 的true条件才会作为过滤条件
const filterNonUniqueBy = (arr, fn) =>
  arr.filter((v, i) => arr.every((x, j) => (i === j) === fn(v, x, i, j)));

log(filterNonUniqueBy(
    [
      { id: 0, value: 'a' },
      { id: 1, value: 'b' },
      { id: 2, value: 'c' },
      { id: 1, value: 'd' },
      { id: 0, value: 'e' }
    ],
    (a, b) => a.id == b.id
  )) // [ { id: 2, value: 'c' } ]
~~~
>[danger] ##### 使用对象作为统计值
~~~
const filterNonUniqueBy  = (ls)=>
    { 
        const obj =  ls.reduce((acc,val)=>{
            acc[val] || (acc[val] = 0)
            acc[val]++
            return acc
        },Object.create(null))
        const uniqls = []
        for(let key in obj) {
            if(obj[key]===1) uniqls.push(key)
        }
        return uniqls
    }

console.log(filterNonUniqueBy([1, 2, 2, 3, 4, 4, 5])) // [ '1', '3', '5' ] 这里有问题数字变字符串还是对象的问题用map
~~~
>[danger] #####  'filter'和'filter' 嵌套使用
~~~
const filterNonUniqueBy  = (ls)=>ls.filter(curr=>ls.filter((val)=>val===curr).length ===1)

console.log(filterNonUniqueBy([1, 2, 2, 3, 4, 4, 5]))
~~~