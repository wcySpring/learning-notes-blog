>[success] # 思考题
~~~
var name = '测试';
function A(x,y){
    var res=x+y;
    console.log(res,this.name);
}
function B(x,y){
    var res=x-y;
    console.log(res,this.name);
}
B.call(A,40,30);
B.call.call.call(A,20,10);
~~~
>[danger] ##### 分析B.call(A,40,30);
~~~
1.call 的源码推理可以知道实际B.call(A,40,30) 内部是A.fn  = B , A.fn(40,30) 这一个推到过程，this 是谁调用
指向谁此时 fn 也就是B ，A调用fn 即相当于A调用了B，此时B中的this 即为A。A.name 值'A',所以打印结果为
10，'A'
~~~
>[danger] ##### 分析 B.call.call.call(A,20,10);
~~~
1.举个例子 const a = { c:{d:'1'}} a.c.d 其实从左到右依次执行，那么B.call.call.call(A,20,10); 就可以看作
B.call.call 调用了 call 方法，根据call 源码内部推到为 A.fn = B.call.call，A.fn(20,10) 即相当于 B.call.call(20,10)
在依次推到 20.fn = B.call 即相当于 B.call(10),最后其实得到B() 此时this 是10 因此打印结果NaN undefined
~~~
